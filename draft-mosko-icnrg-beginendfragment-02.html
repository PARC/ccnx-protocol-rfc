<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>ICN "Begin-End" Hop by Hop Fragmentation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="ICN &quot;Begin-End&quot; Hop by Hop Fragmentation">
<meta name="keywords" content="Content Centric Networking">
<meta name="generator" content="xml2rfc v1.35dev (http://xml.resource.org/)">
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: small; color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: small; font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: small; text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">ICNRG</td><td class="header">M. Mosko</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">PARC</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">C. Tschudin</td></tr>
<tr><td class="header">Expires: June 12, 2017</td><td class="header">University of Basel</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">December 9, 2016</td></tr>
</table></td></tr></table>
<h1><br />ICN "Begin-End" Hop by Hop Fragmentation<br />draft-mosko-icnrg-beginendfragment-02</h1>

<h3>Abstract</h3>

<p>This document describes a simple hop-by-hop fragmentation scheme
        for ICN and mappings to the CCNx 1.0 and NDN packet formats,
        called "begin-end fragmentation". This scheme may be used at Layer 3
        when ICN packets are used natively over a Layer 2 media which does
        not reorder packets.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on June 12, 2017.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2016 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Requirements Language<br />
<a href="#protocol">2.</a>&nbsp;
Abstract Description of the Begin-End-Fragment Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#init">2.1.</a>&nbsp;
Initialization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#init_examples">2.1.1.</a>&nbsp;
Examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sender">2.2.</a>&nbsp;
Sender Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#receiver">2.3.</a>&nbsp;
Receiver Protocol<br />
<a href="#anchor3">3.</a>&nbsp;
Ethernet as a common use case<br />
<a href="#ccnx_protocol">4.</a>&nbsp;
CCNx 1.0 Fragment Protocol Description<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#init_packets">4.1.</a>&nbsp;
Initialization examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#example">4.2.</a>&nbsp;
Example<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FramePacking">4.3.</a>&nbsp;
CCNx 1.0 Frame Packing<br />
<a href="#ndn_protocol">5.</a>&nbsp;
NDN Fragment Protocol Description<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NDNexample">5.1.</a>&nbsp;
Example<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NDNFramePacking">5.2.</a>&nbsp;
NDN Frame Packing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NDNxNumbers">5.3.</a>&nbsp;
Assigned Numbers for NDN Begin-End fragmentation<br />
<a href="#Acknowledgements">6.</a>&nbsp;
Acknowledgements<br />
<a href="#IANA">7.</a>&nbsp;
IANA Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#iana_packettype">7.1.</a>&nbsp;
CCNx Packet Type Registry<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#iana_message">7.2.</a>&nbsp;
CCNx Message Registry<br />
<a href="#Security">8.</a>&nbsp;
Security Considerations<br />
<a href="#pseudocode">9.</a>&nbsp;
Reset Pseudocode<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>In the past, there were two known hop-by-hop fragmentation schemes for
         ICN packets: The one described in <a class='info' href='#NDNLP'>NDNLP<span> (</span><span class='info'>Shi, J. and B. Zhang, &ldquo;NDNLP: A Link Protocol for NDN,&rdquo; July&nbsp;2012.</span><span>)</span></a> [NDNLP] 
         as "indexed fragmentation" and the one implemented in
         <a class='info' href='#CCNLite'>CCN-lite<span> (</span><span class='info'>Mosko, M., Plass, M., and C. Tschudin, &ldquo;CCN-Lite fragmentation,&rdquo; Summer 2012.</span><span>)</span></a> [CCNLite], 
         using the old ccnb encoding. In a first part, this
         document describes a third,  hop-by-hop fragmentation
         protocol in an encoding-neutral way. In a second part, we show mappings of this "begin-end fragmentation scheme" to
         the
         <a class='info' href='#CCNMessages'>CCNx Messages in TLV Format<span> (</span><span class='info'>Mosko, M., Solis, I., and C. Wood, &ldquo;CCNx Messages in TLV Format (Internet draft),&rdquo; 2016.</span><span>)</span></a> [CCNMessages] and the NDN TLV [NDN] encoding.
         Thirdly, possible extensions and their encodings are discussed, for example
         reporting link reliability or link ARQ schemes such as windowing
         protocols.
</p>
<p>The proposed hop-by-hop "begin-end fragments" scheme may be used
         at Layer 3 when large ICN messages are to be natively sent over a
         Layer 2 media with a small MTU. In cases where ICN packets are
         carried over an existing Layer 3 protocol, such as IP, the Information
         Centric Network SHOULD use that protocol's native fragmentation.
       
</p>
<p>This proposed fragmentation scheme is an adaptation of PPP Multilink
         <a class='info' href='#RFC1990'>PPP Multilink<span> (</span><span class='info'>Sklower, K., Lloyd, B., McGregor, G., Carr, D., and T. Coradetti, &ldquo;The PPP Multilink Protocol (MP),&rdquo; August&nbsp;1996.</span><span>)</span></a> [RFC1990] fragmentation between peers
         identified by their Layer 2 identity. It is appropriate for standard
         Layer 2 media that guarantee in-order packet delivery.
       
</p>
<p>Definitions:
         </p>
<ul class="text">
<li>(Network Protocol) Packet: A layer 3 ICN datagram, such as a
              Content Object or Interest, which is too large to be
              transmitted over a given L2 technology.
</li>
<li>Fragment: The datagram containing all serialized data fields
              required by the proposed fragmentation protocol. Depending on
              the mapping, the fragment will contain these fragment protocol
              specific data but also, for example, a CCNx fixed header,
              optional Per-Hop-Headers and/or and validator fields like
              checksums or signatures.
</li>
<li>Fragment Header: The serialized CONTROL data structures of
              the proposed fragmentation protocol plus mapping
              specific bits.
</li>
<li>Fragment Data (or payload): The portion of the original
              Network Protocol Packet that is carried in the Fragment.
</li>
<li>Frame: A layer-2 frame in which the Fragment will be
              transferred.
</li>
</ul><p>
       
</p>
<p>Fragments are represented as 32-bit wide words using ASCII
      art.  Because of the Type-Length-Value encoding used (TLV) and
      optional fields or sizes, there is no concise way to represent
      all possibilities.  We use the convention that ASCII art fields
      enclosed by vertical bars "|" represent exact bit widths.
      Fields with a forward slash "/" are variable bit widths, which we
      typically pad out to word alignment for picture readability.
</p>
<p>TODO -- we have not adopted the Requirements Language yet.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<a name="protocol"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Abstract Description of the Begin-End-Fragment Protocol</h3>

<p>A Fragment is defined as the following fields (plus any
        additional fields required by the wire formatting in which
        fragments are encoded):
        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Fragment       = FragProtocolID FragProtocolData
FragProtocolID = &lt;BeginEndFragmentsProtocolID&gt; | (other protocols' ids)
FragProtocolData = BeginEndFragmentsData | (other protocols' data)
BeginEndFragmentsData = Flags FragSeqNo FragLength FragData
Flags          = B / E / BE / I
B              = &lt;begin flag&gt;
E              = &lt;end flag&gt;
BE             = &lt;begin and end flag&gt;
I              = &lt;idle flag&gt;
FragSeqNo      = 1*OCTETS
FragLength     = &lt;Octets of fragment data&gt;
FragData       = &lt;Continuous octets (portion of Packet)&gt;
</pre></div><p>

      
</p>
<p>The fragmentation protocol is run between a sender and a "peer",
        which can be one or more, potentially passive, receivers.
        They execute first an <a class='info' href='#init'>Initialization Protocol<span> (</span><span class='info'>Initialization</span><span>)</span></a>,
        then use a <a class='info' href='#sender'>Sender Protocol<span> (</span><span class='info'>Sender Protocol</span><span>)</span></a> and
        <a class='info' href='#receiver'>Receiver Protocol<span> (</span><span class='info'>Receiver Protocol</span><span>)</span></a> to exchange frames.
      
</p>
<p>The initialization protocol uses a reliable messages exchange
        to reset the the FragSeqNo to 0 on both peers.  This ensures that
        when one or another peer restarts both peers will reset their state.
</p>
<p>The sender breaks a packet P (typically an Interest- or
          Content packet in the embedding wire encoding) into one or
          more fragments which are tagged with monotonically
          increasing sequence numbers. The B, E and BE flags are used
          to signal the start of a fragment series (B), its end (E),
          or a single fragment (BE) for the given packet P.
        
</p>
<p>It is advisable that the 'B' fragment contains enough
          information in its Fragment Data to let the receiver know
          the total length of the packet to be reconstructed (and size
          of the reassembly buffer to be allocated) and the type of the
          expected packet.
        
</p>
<p>The receivers listen to the fragment stream and reconstruct
          from a valid fragment series the original packet, and reject
          fragments with invalid sequence numbers, flags, or
          validation data.
        
</p>
<p>The 'I' flag allows the sender to send idle frames that do
           not contain any Fragment Data, but do increment the fragment
           sequence number.  This is useful on lossy links to indicate that
           the sender is past the end of the previous packet in
           case the 'E' fragment was lost.  Moreover, as a possible
           extension of the protocol, this allows for periodic keepalives,
           measuring for example
           link quality when there is no other traffic to send.
        
</p>
<a name="init"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Initialization</h3>

<p>Whenever a peer begins operation, it must reliably reset the
          sequence number space.  If the underlying link already ensures
          a complete reset of both peers, that method MAY be used.  Otherwise,
          the method presented here SHOULD be used.
</p>
<p>
          </p>
<ol class="text">
<li>For each peer, a node tracks its local state, S_LOCAL[peer], and its peer's state S_REMOTE[peer].  A
              state may be INIT or Sync or OK, though only certain combinations are possible.
</li>
<li>A node tracks its FragSeqNo as FSN_LOCAL[peer] and the next expected FragSeqno
              from its peer as FSN_REMOTE[peer].
</li>
<li>A node remembers two numbers N_LOCAL[peer] and N_REMOTE[peer].  N_LOCAL is the
            node's own sequence number and N_REMOTE is the one learned from a peer.  These two
            numbers identify the current reboot of a node and serve as computation identifiers.
            They may be sequence numbers or random numbers or taken from some other source that
            is unlikely to repeat reboot to reboot.
</li>
<li>A RESET message carries a nodes N_LOCAL[peer] value and informs the peer that it
            should reset it's fragment sequence numbers.
</li>
<li>Upon receiving a RESET, a node will set N_REMOTE[peer] to the RESET number and
            will send a RESETACK message to acknowledge the RESET and to inform the peer of
            it's own N_LOCAL[peer] number.  Thus a RESET mesage carries one value and
            a RESETACK carries two values.
</li>
<li>We will drop the [peer] subscript from the state variables in the following with the
               understanding that this protocol executes per pair of peers.
</li>
<li>If a node is not in the OK/OK state, it MUST send only RESET or RESETACK messages.
</li>
<li>Upon sending a first RESET message, the sending node starts a retransmit timer for
              the peer.  It begins at RESET_TIMOUT (50 msec).
</li>
<li>At each RESET timeout, a node sets a new timeout as twice the previous timeout.
              If it is less than MAX_TIMEOUT (4 seconds), it sends {RESET, N_LOCAL} again and starts
              a reset timer with the new timeout.
</li>
<li>Upon receiving a valid RESETACK that matches a node's N_LOCAL, the RESET timeout
           is set back to RESET_TIMEOUT.
</li>
</ol><p>
        
</p>
<p>
        Figures 1 - 3 show the reset state machine.  Section <a class='info' href='#pseudocode'>Section&nbsp;9<span> (</span><span class='info'>Reset Pseudocode</span><span>)</span></a> provides
        pseudocode for the same state machine.  In the figures, we use short abbreviations for
        compactness.  N_L is N_LOCAL, N_R is N_REMOTE, FSN_L is FSN_LOCAL, FSN_R is FSN_REMOTE.
        We also abbreviate RESET as RST and RESTACK as RSTACK.  Double line boxes indicate
        a potentially blocking state that responds to external events (timeouts or packet
        reception).  Single line boxes indicate transient states the perform some operation.
        
</p>
<p>Figure 1 shows the initial state of a system as REBOOT.  REBOOT state will ignore
        any received packets and initialize the state variables.  After rebooting, a node
        will be in the INIT, INIT state.  From here, it may either receive a RESET
        message from its peer or send its own RESET message.  In the first case, it proceeds
        to X2 (the slave state), in the second case it proceeds to X1 (the master state).
        
</p>
<p>Figure 2 shows the master state, where the system sends out a RESET before
        receiving a RESET from a peer.  In state SYNC, INIT, the node is waiting for
        either a RESETACK or a RESET from its peer.  If it does not receive either before
        its timeout, it will double its timeout and send another RESET
</p>
<p>Figure 3 shows the slave state, where the system has received a RESET from
        its peer before it has sent its own RESET.  This puts the node in the INIT, OK state.
        Typically, a node will immediately send its own RESET message, though the RESETACK
        its sends has the same effect.  This puts the node in the SYNC, OK state.  One
        of three events can happen: a timeout to send another RESET message, receive
        a RESETACK or receive another RESET.  Upon receiving a valid RESETACK, the
        node can move to the OK, OK state. 
</p>
<p>
 <br /><hr class="insert" />
<a name="fig-reboot"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  +-------------------------+
  |                         v
+-------+  recv any       #===============#
| Drop  | &lt;-------------- H    Reboot     H
+-------+                 #===============#
                            |
                            |
                            v
                          +---------------+
                          | N_L=N, N_R=0, |
                          | FSN_R=FSN_L=0 |
                          +---------------+
                            |
                            |
                            v
.........  recv (RST M)   #===============#
: To X2 : &lt;-------------- H  Init, Init   H
:.......:                 #===============#
                            |
                            |
                            v
                          .................
                          :     To X1     :
                          :...............:
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Reboot State&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
   
<br /><hr class="insert" />
<a name="fig-x1"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 .....................        +-------------------+
 :        X1         : ----&gt;  |  Send RST(N_L)    | &lt;--------+
 .....................        +-------------------+          |
                                      |                      |
                                      v                      |
                              +-------------------+   +--------------+
                              |    Start Timer    |   | Inc. Timeout |
                              +-------------------+   +--------------+
                                      |                      ^
                      recv(RST M)     v                      |
 +-------------------+        #===================#  timeout |
 |     N_R = M       | &lt;----- H    Sync, Init     H ---------|
 +-------------------+        #===================#
       |                              | recv(RSTACK N,M)
       v                              v
 .....................        +-------------------+  no    +----------+
 :       To X4       :        |     If N=N_L      | -----&gt; |   Drop   |
 :...................:        +-------------------+        +----------+
                                      | yes
                                      v
                              +-------------------+
                              |   Cancel Timer    |
                              |   Reset Timeout   |
                              |      N_R = M      |
                              +-------------------+
                                      |
                                      v
                              +-------------------+
                              |       Send        |
                              | RSTACK(N_R, N_L)  | &lt;+
                              +-------------------+  |
                                       |             | yes
                    recv RSTACK(N, M)  v             |
   +-------------------+      #===================#  |
+- | If N=N_L &amp;&amp; M=N_R | &lt;--- H      OK, OK       H &lt;+------+
|  +-------------------+      #===================#  |      |
|    | no                              | recv RST(M) |      |
|    v                                 v             |      |
|  .....................  no  +-------------------+  |      | yes
|  :       To X3       : &lt;--- |     If M=N_R      | -+      |
|  :...................:      +-------------------+         |
|                                                           |
+-----------------------------------------------------------+
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Master State&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
   

<br /><hr class="insert" />
<a name="fig-x2"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

 ...........       +-------------------+
 :   X2    : ----&gt; |       N_R=M       | &lt;----+
 :.........:       +-------------------+      |
                       |                      | recv (RST M)
                       v                      |
                   +-------------------+    #===================#
                   |       Send        | -&gt; H     Init, OK      H
                +&gt; |  RSTAK(N_R, N_L)  |    #===================#
                |  +-------------------+      |
                |                             |
                |  +-------------------+      |
                |  |   Send RST(N_L)   | &lt;----+
                |  |    Start Timer    | &lt;------------------------+
                |  +-------------------+                          |
                |    |                                            |
                |    v                                            |
                |  #====================================#  recv   |
  +-------------+&gt; H            Sync, OK                H --------+---+
  |             |  #====================================# (RST M) |   |
  |             |      | recv (RSTAK N,M)   | timeout             |   |
  |             |      v                    |                     |   |
  |  +------+   |    +-----------------+    |      +---------------+  |
  |  | Drop | &lt;-+--- |   If N=N_L      |    +----&gt; | Inc. Timeout  |  |
  |  +------+   |no  +-----------------+           +---------------+  |
  |             |     | yes                   recv (RST M) +----------+
  |             |     v                                    v
  |             |  +-------------------+           +---------------+
  |             |  |   Cancel Timer    |           | If M=N_REMOTE | yes
  |             |  |   Reset Timeout   |           |               | -+
  |             |  +-------------------+           +---------------+  |
  |             |      |                             | no             |
  |  .........  |      v                             v                |
  |  :   To  :  |    +-----------------+           +---------------+  |
  |  : OK,OK :&lt;-+--- |  If M=M_REMOTE  |           | Cancel Timer  |  |
  |  .........  |yes +-----------------+           +---------------+  |
  |             |      | no                          |                |
  |             |      v                             |                |
  |             |  +-------------------+             |                |
  |  ........   +- |      N_R=M,       | &lt;-----------+                |
  |  :  X3  : ---&gt; |   FSN_R=FSN_L=0   |                              |
  |  ........      +-------------------+                              |
  +--------------------- +    +-------------------+                   |
               ........  +--&lt; |       Send        |                   |
               :  X4  : ----&gt; |  RSTAK(N_R, N_L)  | &lt;-----------------+
               ........       +-------------------+
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Slave State&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
           

</p>
<a name="init_examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.1"></a><h3>2.1.1.&nbsp;
Examples</h3>

<p>The first example, <a class='info' href='#example1'>Figure&nbsp;4</a> shows an example message
            sequence diagram of the initialization process.  The "T" column is Time, The "S"
            column is for S_LOCAL and S_REMOTE, the N column is for N_LOCAL and N_REMOTE,
            and the FSN column is for FSN_LOCAL and FSN_REMOTE.  We show both peers, one on the
            left side of the figure and one on the right side; call them nodes "A" and "B".
            We only show an entry in the table when state changes.
            </p>
<ul class="text">
<li>T=0: A initializes and sets its state values as shown, picking
                the message sequence number 5.  It sends the message
                {RESET, 5} to B.  It starts a RESET timer.
              
</li>
<li>
                T=2: Node B initializes, picking message sequence number 7.  It sends
                {RESET, 7} to A.  It starts a RESET timer.
              
</li>
<li>T=3: Node A receives {RESET, 7}.  It sets S_REMOTE to OK and records
                N_REMOTE as 7.  It sets FSN_LOCAL and FSN_REMOTE to 0.
              
</li>
<li>
                T=4: Node A sends {RESET_ACK, 7} to node B.
              
</li>
<li>
                T=5: Node B reeives {RESET_ACK, 7}, so it sets S_LOCAL to OK.
                It cancels its RESET timer.
              
</li>
<li>
                T=6: Node A's RESET timer expires and it re-sends {RESET, 5} to B.
              
</li>
<li>
                T=7: Node B receives {RESET, 5}.  It records N_REMOTE as 5 and sets
                S_REMOTE to OK.  At this point, Node B is in OK/OK state and may begin
                sending data.
              
</li>
<li>
                T=8: Node B sends {RESET_ACK, 5}.
              
</li>
<li>
                T=9: Node B begins sending data to A.
              
</li>
<li>
                T=9: Node A reveives {RESET_ACK, 5} and sets S_LOCAL to OK.  It is now
                in OK/OK state and may begin sending data to B.
              
</li>
<li>
                T=10: Node A begins sending data to B.
              
</li>
</ul><p>
          
</p><br /><hr class="insert" />
<a name="example1"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
|---|-----|-----|-----|                        |-----|-----|-----|
| T |  S  |  N  | FSN |                        |  S  |  N  | FSN |
|   | L R | L R | L R |                        | L R | L R | L R |
|---|-----|-----|-----|                        |-----|-----|-----|
| 0 | I I | 5 0 | 0 0 | &gt;-{RESET, 5}---------&gt;X|    not ready    |
|   |     |     |     |                        |     |     |     |
| 2 |     |     |     | &lt;---------{RESET, 7}-&lt; | I I | 7 0 | 0 0 |
| 3 |   OK| 5 7 | 0 0 |                        |     |     |     |
| 4 |     |     |     | &gt;-{RESET_ACK, 7}-----&gt; |     |     |     |
| 5 |     |     |     |                        |OK   | 7 0 | 0 0 |
| 6 |     |     |     | &gt;-{RESET, 5}---------&gt; |     |     |     |
| 7 |     |     |     |                        |   OK|   5 | 0 0 |
| 8 |     |     |     | &lt;-----{RESET_ACK, 5}-&lt; |     |     |     |
| 9 |OK   |     |     | &lt;-------------{data}-&lt; |     |     |     |
| 10|     |     |     | &gt;-{data}-------------&gt; |     |     |     |
|---|-----|-----|-----|                        |-----|-----|-----|
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sender"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Sender Protocol</h3>

<p>
          </p>
<ol class="text">
<li>A sender maintains a separate state machine for each peer.
</li>
<li>When a peering is established, the FragSequenceNumber
               begins at 0.
</li>
<li>After sending a Fragment, FragSequenceNumber is
               incremented by one.
</li>
<li>In the first fragment for a packet, set the B bit to '1'.
</li>
<li>In the last fragment for a packet, set the E bit to '1'.
</li>
<li>Both the B and E bits must be set to '1' for a single
               fragment.
</li>
<li>If both the B and E and I bits are not set, the fragment
               is in the middle of a series.
</li>
<li>When not sending a fragment (with fragment data), the
              sender may send an Idle fragment with only the 'I' bit
              set. This indicates that the sender has no packet to send.
              Idle frames may only be sent in between E and B frames.
</li>
</ol><p>
        
</p>
<a name="receiver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Receiver Protocol</h3>

<p>
          </p>
<ol class="text">
<li>A receiver maintains one reassembly queue per sender.
</li>
<li>Discard Idle fragments.
</li>
<li>Discard fragments until a 'B' fragment is received.
               Store the received sequence number for this sender.
</li>
<li>If an out-of-order fragment is received next, discard the
               reassembly buffer and go to step (2).
</li>
<li>Continue receiving in-order fragments until the first
              'E' fragment.  At this time, the fragmented packet is
              fully re-assembled and may be passed on to the next
              layer.
</li>
<li>The receiver cannot assume it will receive the 'E'
              fragment or a subsequent 'I' frame, so it should use a
              timeout mechanism appropriate to the link to release
              preallocated memory resources.
</li>
</ol><p>
        
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Ethernet as a common use case</h3>

<p>We expect that Ethernet will be the most common L2
         technology where the proposed ICN fragmentation will be used,
         therefore we briefly elaborate on how fragmentation functions
         with the broadcast and multi-protocol nature of Ethernet.
       
</p>
<p>When the fragmentation protocol is used with Ethernet, each
         participant uses the tuple {source mac, destination mac,
         ethertype} to identify a send or receive buffer and
         FragSequenceNumber number space.
       
</p>
<p>
         If the fragmentation protocol is using a group address destination,
         each group address is considered a "peer" with its
         own FragSequenceNumber.  For example, the MAC address
         0x01005E0017AA on EtherType 0x0801 is the CCNx assigned group
         address for its 224.0.23.170 IP multicast address.  Each
         sender would maintain a FragSequenceNumber for that peer.  Each
         receiver would maintain a separate reassembly buffer for that group
         address based on the sender and ethertype.
       
</p>
<p>
         If using other Ethernet encapsulations, such as 802.1AE MacSec, one could
         use a security identifier in place of the {source, destination, ethertype} tuple.
       
</p>
<a name="ccnx_protocol"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
CCNx 1.0 Fragment Protocol Description</h3>

<p>The hop-by-hop fragmentation protocol introduces a new CCNx
        1.0 Packet Type called PT_FRAG and uses new fields in the
        Fixed Header.  The hop-by-hop headers of a CCNx 1.0 fragment
        may be used for purposes like link quality reporting or a
        reliable ARQ scheme, which are out-of-scope of this document.
       
</p>
<p>We describe a basic hop-by-hop fragmentation header, using bits
      in the Fixed Header for the fragment encoding.  We also describe
      an extended version with variable sequence number size that puts the
      fragmentation header in the body of the CCNx message.  This allows
      the fragmentation header to be signed or covered by a MIC.  The
      extended encoding sets the 'X' flag to 1 in the Fixed Header, otherwise
      it is the basic encoding.
</p>
<p>The "hop-by-hop fixed header" follows the normal conventions:
        The Version, PacketLength, and HeaderLength fields are as per
        <a class='info' href='#CCNMessages'>CCNx Messages in TLV Format<span> (</span><span class='info'>Mosko, M., Solis, I., and C. Wood, &ldquo;CCNx Messages in TLV Format (Internet draft),&rdquo; 2016.</span><span>)</span></a> [CCNMessages].  The PacketType is set to
        PT_FRAG. However, in the packet-type dependent fields, we
        reserve 4 bits for flags and 20 bits for a sequence
        number.
</p>
<p>The "message part" of the CCNx 1.0 fragment carries the
        fragment data in its own TLV block. The message part may also
        contain standard CCNx validation algorithm and validation
        bits in subsequent TLV blocks. In this way, the fragment can
        be covered by a CRC32C checksum or stronger validation
        methods.
</p>
<p>The new TLV type T_FRAGMENT wraps the fragment bytes.
        It is a top-level message TLV, similar to T_INTEREST or T_OBJECT.
</p>
<p>For sequence number reset, the new TLV types T_FRAG_RESET
        and T_FRAG_RESET_ACK carry the initialization message sequence number.
        They MUST appear in an Idle (I) frame.
        A packet MUST NOT have T_FRAGMENT if it has one of these fields.
        A single packet may have both a T_FRAG_RESET and a T_FRAG_RESET_ACK.
        These fields appear in the CCNx message section.
        It is RECOMMENDED to use a 64-bit sequence number, though an 
        implementation MAY use any length appropriate to the media.
      
</p>
<p>T_FRAG_RESET and T_FRAG_RESET_ACK may be in either basic
        header or extended header packets.  In extended header format,
        the T_FRAG_HEADER element MUST be length 1, which conveys only
        the flags.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |    PT_FRAG    |         PacketLength          |
+---------------+---------------+---------------+---------------+
|X|B|E|I|          FragSequenceNumber           | HeaderLength  |
+---------------+---------------+---------------+---------------+
/ Optional Hop-by-hop header in TLV format                      /
+---------------+---------------+---------------+---------------+
| Fragment Data TLV                                             /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationAlgorithm TLV                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationPayload TLV (ValidationAlg required)  /
+---------------+---------------+---------------+---------------+
</pre></div>
<p>
        </p>
<ul class="text">
<li>X: Extended Format (X=0 shown above)
</li>
<li>B: Begin flag.
</li>
<li>E: End flag.
</li>
<li>I: Idle flag.
</li>
<li>FragSequenceNumber: a 20-bit sequence number to identify the
            fragment (see below).
</li>
</ul><p>
      
</p>
<p>The FragSequenceNumber follows <a class='info' href='#RFC1982'>Serial
        Number Arithmetic<span> (</span><span class='info'>Elz, R. and R. Bush, &ldquo;Serial Number Arithmetic,&rdquo; August&nbsp;1996.</span><span>)</span></a> [RFC1982] for a 20-bit serial number.  This
        means we have 19 bits of "valid" sequence number space, or
        524,288 fragments.  The packets per second for a 10 Gbps link
        with 1500 bytes Ethernet frames is 833,333 packets per second.
        Therefore, the 20-bit sequence number space allows for 629
        milliseconds of frames.
</p>
<p>In CCNx 1.0, the maximum encapsulated length is 64 KB --
        which requires under 50 PT_FRAG frames of 1500 bytes,
        depending on the HeaderLength and validation options. So the
        valid sequence number space (when e.g. used over Ethernet) is
        approximately 10,500 maximum size (network protocol) packets.
      
</p>
<p>If a PT_FRAG packet has optional hop-by-hop headers, the
      implementation should pass the fragment to the appropriate
      subsystem to process those headers before discarding the
      fragment.
</p>
<p>The Extended encoding (X=1) moves the fragment header fields (=
        flags and sequence number) to the CCNx packet's message part,
        so they are covered by any ValidationAlgorithm used on the
        packet.  It also allows for variable length sequence numbers.
        In the example shown below, there is a 7-byte (56-bit)
        sequence number.

      
</p>
<p>The Extended encoding also allows different fragmentation
      protocols to co-exist by changing the opening TLV type from 
      T_FRAG_HEADER to a new type.
</p>
<p>The first 8 bytes of the first fragment are the FixedHeader
      of the encapsulated Packet, so one may learn the overall length
      of the Packet from that FixedHeader.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |    PT_FRAG    |         PacketLength          |
+---------------+---------------+---------------+---------------+
|1|0|0|0|                 Reserved              | HeaderLength  |
+---------------+---------------+---------------+---------------+
/ Optional Hop-by-hop header in TLV format                      /
+---------------+---------------+---------------+---------------+
|          T_FRAG_HEADER        |               8               |
+---------------+---------------+---------------+---------------+
|1|B|E|I|0|0|0|0|           FragSequenceNumber                  /
/                                                               /
+---------------+---------------+---------------+---------------+
| Fragment Data TLV                                             /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationAlgorithm TLV                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationPayload TLV (ValidationAlg required)  /
+---------------+---------------+---------------+---------------+
</pre></div>
<a name="init_packets"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Initialization examples</h3>

<p>This section presents examples of initialization packets.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |    PT_FRAG    |         PacketLength          |
+---------------+---------------+---------------+---------------+
|0|0|0|1|                0                      | HeaderLength  |
+---------------+---------------+---------------+---------------+
/ Optional Hop-by-hop header in TLV format                      /
+---------------+---------------+---------------+---------------+
| T_FRAG_RESET (optional)       |               8               |
+---------------+---------------+---------------+---------------+
/ 64-bit N_LOCAL value                                          /
+---------------+---------------+---------------+---------------+
| T_FRAG_RESET_ACK (optional)   |               8               |
+---------------+---------------+---------------+---------------+
/ 64-bit N_LOCAL value                                          /
/ 64-bit N_REMOTE value                                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationAlgorithm TLV                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationPayload TLV (ValidationAlg required)  /
+---------------+---------------+---------------+---------------+
</pre></div><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |    PT_FRAG    |         PacketLength          |
+---------------+---------------+---------------+---------------+
|1|0|0|0|                 Reserved              | HeaderLength  |
+---------------+---------------+---------------+---------------+
/ Optional Hop-by-hop header in TLV format                      /
+---------------+---------------+---------------+---------------+
|          T_FRAG_HEADER        |               1               |
+---------------+---------------+---------------+---------------+
|1|0|0|1|0|0|0|0|
+---------------+---------------+---------------+---------------+
| T_FRAG_RESET (optional)       |               8               |
+---------------+---------------+---------------+---------------+
/ 64-bit N_LOCAL value                                          /
+---------------+---------------+---------------+---------------+
| T_FRAG_RESET_ACK (optional)   |               8               |
+---------------+---------------+---------------+---------------+
/ 64-bit N_LOCAL value                                          /
/ 64-bit N_REMOTE value                                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationAlgorithm TLV                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationPayload TLV (ValidationAlg required)  /
+---------------+---------------+---------------+---------------+
</pre></div>
<a name="example"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Example</h3>

<p>We present a complete example of the basic fragment encoding for a 2KB Content
        Object for 1500 byte frames according to the protocol
        described in this draft (with clear X-flag). The original 2KB
        packet also has an RSA signature, but this cannot easily be
        used for integrity checking as the receiver may not have the
        appropriate key and it is an expensive operation. We therefore
        chose to use a CRC32C validator on each fragment.  The Content
        Object has the name ccnx:/abcd.  First, the original 2000 byte
        packet is shown in entirety.
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|       1       |       2       |              2000             |
+---------------+---------------+---------------+---------------+
|            Reserved           |     Flags     |       20      |
+---------------+---------------+---------------+---------------+
|         T_CACHETIME           |               8               |
+---------------+---------------+---------------+---------------+
|                                                               |
|                    Recommended Cache Time                     |
+---------------+---------------+---------------+---------------+
|       T_CONTENTOBJECT         |              1508             |
+---------------+---------------+---------------+---------------+
|            T_NAME             |               8               |
+---------------+---------------+---------------+---------------+
|         T_NAMESEGMENT         |               4               |
+---------------+---------------+---------------+---------------+
|       a                b              c              d        |
+---------------+---------------+---------------+---------------+
|           T_PAYLOAD           |              1492             |
+---------------+---------------+---------------+---------------+
/                        Payload Contents                       /
+---------------+---------------+---------------+---------------+
|       T_VALIDATION_ALG        |              204              |
+---------------+---------------+---------------+---------------+
|          T_RSA-SHA256         |              200              |
+---------------+---------------+---------------+---------------+
|             T_KEYID           |               32              |
+---------------+---------------+---------------+---------------+
/                            KeyId                              /
/---------------+---------------+-------------------------------+
|          T_PUBLICKEY          |              160              |
+---------------+---------------+---------------+---------------+
/                Public Key (DER encoded SPKI)                  /
+---------------+---------------+---------------+---------------+
|     T_VALIDATION_PAYLOAD      |              256              |
+---------------+---------------+---------------+---------------+
/                          RSA Signature                        /
+---------------+---------------+---------------+---------------+
</pre></div>
<p>The 2000 byte packet will be fragmented into two pieces.
 In the first fragment, there is 28 bytes of
      overhead (fixed header 8, T_STD_FRAGMENT 4, validation 16), so
      the fragment's payload size is 1472 bytes.  In the second
      packet, the T_FRAGMENT block carries the remaining data 528
      bytes, hence the overall packet size is 556 bytes due to the
      same 28 bytes of overhead.  We used FragSequenceNumber "0" and
      "1" for the two fragments.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|       1       |    PT_FRAG    |              1500             |
+---------------+---------------+---------------+---------------+
|0|1|0|0|                  0x00000              |       8       |
+---------------+---------------+---------------+---------------+
|          T_FRAGMENT           |             1472              |
+---------------+---------------+---------------+---------------+
|       1       |       2       |              2000             |
+---------------+---------------+---------------+---------------+
|            Reserved           |     Flags     |       20      |
+---------------+---------------+---------------+---------------+
|         T_CACHETIME           |               8               |
+---------------+---------------+---------------+---------------+
|                                                               |
|                    Recommended Cache Time                     |
+---------------+---------------+---------------+---------------+
|       T_CONTENTOBJECT         |              1508             |
+---------------+---------------+---------------+---------------+
|            T_NAME             |               8               |
+---------------+---------------+---------------+---------------+
|         T_NAMESEGMENT         |               4               |
+---------------+---------------+---------------+---------------+
|       a                b              c              d        |
+---------------+---------------+---------------+---------------+
|           T_PAYLOAD           |              1492             |
+---------------+---------------+---------------+---------------+
/             Payload Contents  (1432 out of 1492 bytes)        /
+---------------+---------------+---------------+---------------+
|      T_VALIDATION_ALG         |               4               |
+---------------+---------------+---------------+---------------+
|            T_CRC32            |               0               |
+---------------+---------------+---------------+---------------+
|     T_VALIDATION_PAYLOAD      |               4               |
+---------------+---------------+---------------+---------------+
|                         CRC32C Value                          |
+---------------+---------------+---------------+---------------+
</pre></div><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                    1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|       1       |    PT_FRAG    |              556              |
+---------------+---------------+---------------+---------------+
|0|0|1|0|                  0x00001              |       8       |
+---------------+---------------+---------------+---------------+
|          T_FRAGMENT           |             528               |
+---------------+---------------+---------------+---------------+
/                Payload Contents  (last 60 bytes)              /
+---------------+---------------+---------------+---------------+
|       T_VALIDATION_ALG        |              204              |
+---------------+---------------+---------------+---------------+
|          T_RSA-SHA256         |              200              |
+---------------+---------------+---------------+---------------+
|             T_KEYID           |               32              |
+---------------+---------------+---------------+---------------+
/                            KeyId                              /
/---------------+---------------+-------------------------------+
|          T_PUBLICKEY          |              160              |
+---------------+---------------+---------------+---------------+
/                Public Key (DER encoded SPKI)                  /
+---------------+---------------+---------------+---------------+
|     T_VALIDATION_PAYLOAD      |              256              |
+---------------+---------------+---------------+---------------+
/                          RSA Signature                        /
+---------------+---------------+---------------+---------------+
|      T_VALIDATION_ALG         |               4               |
+---------------+---------------+---------------+---------------+
|            T_CRC32            |               0               |
+---------------+---------------+---------------+---------------+
|     T_VALIDATION_PAYLOAD      |               4               |
+---------------+---------------+---------------+---------------+
|                         CRC32C Value                          |
+---------------+---------------+---------------+---------------+
</pre></div>
<a name="FramePacking"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
CCNx 1.0 Frame Packing</h3>

<p>A sender/receiver pair may multiplex non-fragmentation
         frames on the same link.  For example, in CCNx 1.0, there
         may be some PacketType PT_FRAG frames and some plain
         PT_INTEREST or PT_CONTENTOBJECT frames on the same link
         between the same pairs.  PT_FRAG frames are considered
         independently of other frames between the pair.
</p>
<p>Because each CCNx 1.0 datagram with a Fixed Header has all
        information needed for framing, two peers may pack multiple
        CCNx 1.0 datagrams in to one Layer 2 frame.  For example, if
        there are several small Interests queued back-to-back,
        they could be encapsulated in a single Ethernet frame, up to
        the maximum Ethernet payload.
</p>
<p>At the extreme, a peer may use fragmentation for all
        packets and completely pack each Layer 2 frame.  The tail
        fragment would be cut off at whatever byte length fits the
        remaining Layer 2 frame.
</p>
<p>Example: Assume that the outgoing queue for a specific peer has
          the following four packets to be sent:
        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
interest1(200B)
content1(3500B)
interest2(200B)
content2(500B)
</pre></div><p>

          With 12 bytes of overhead per fragment these four packets could
          be fragmented and packeted into three Ethernet frames as:
        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
[frag(interest1,200B), frag(content1, 1276B)]
[frag(content1, 1488B)]
[frag(content1, 236B), frag(interest2, 200B), frag(content2, 500B)]
</pre></div><p>

        
</p>
<a name="ndn_protocol"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
NDN Fragment Protocol Description</h3>

<p>The Begin-End fragmentation protocol described in this draft
         extends the NDN link protocol v2 packet format
         (NDNLPv2). Note that this extension is not an official part
         of the NDN suite, at this point in time.
</p>
<p>NDNLPv2 packets have a start type NDNLP-TYPE which
         distinguishes them from the classic Interest and Data
         packets. Inside the NDNLPv2 TLV structure, a sequence of
         NDNLPv2 header fields precede the payload (fragment data)
         which is introduced by the type value NND-FRAGMENT-TYPE.
        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         NDNpacket      ::= Interest | Data | NDNLP
         NDNLP          ::= NDNLP-TYPE TLV-LENGTH
                              NDNLPhdrFields*
                              NDNLPfragment?
         NDNLPhdrFields ::= BeginEndField | (other NDNLP header fields)
         BeginEndField  ::= BEGIN-END-FIELD-TYPE TLV-LENGTH
                              BYTE BYTE+
         NDNfragment    ::= NDN-FRAGMENT-TYPE TLV-LENGTH
                              BYTE+
</pre></div><p>

</p>
<p>The extension for the "begin-end" fragmentation scheme
         relies on a new header field with type value
         NDN-BEGIN-END-FIELD-TYPE: The presence of this field marks a
         NDNLPv2 packet as a "begin-end" fragment. The field's value is
         1 to 8 bytes long and consists of 2 flag bits
         (most-significant bits) plus a sequence number (remaining
         less-significant bits).
</p>
<p>For a sender/receiver pair and for a given direction, the
         value of the BeginEndField is of constant size. But depending
         on the start configuration, different sizes can be chosen for
         operations, both in time and for the different
         directions.
</p>
<p>In the smallest possible setup (e.g. sensor network with
         very small MTUs), the BeginEndField can have a one-byte value
         (2 flag bits plus 6 sequence number bits). For Ethernet, it
         it is recommended to use a 3-byte value (2 flag bits plus 22
         sequence number bits).
</p>
<p>An idle fragmentation frame is encoded as a NDNLP packet
         with a Begin-End Field but no NDNfragment element. Both the B-
         and the E-flags should be set to 1 in this case.
</p>
<p>The frist bytes of the first fragment are the outermost
      NDN TLV of the encapsulated Packet.  One may learn the overall
      length from the the outermost TLV length.
</p>
<a name="NDNexample"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Example</h3>

<p>We present an example of the basic fragment encoding for a
       payload of size larger than 253 Bytes and less than 64KB.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
| type=NDNLP    | len=N+9                                       |
+---------------+---------------+---------------+---------------+
| type=BeginEnd | len=3         |B|E|        FragSequence...    |
+---------------+---------------+---------------+---------------+
| ..Number      | type=Fragment | len=N                         |
+---------------+---------------+---------------+---------------+
|               | FragmentData (N bytes) ...                    /
+---------------+---------------+---------------+---------------+
/                                                               /
+---------------+---------------+---------------+---------------+
/               |
+---------------+
</pre></div>
<p>
        </p>
<ul class="text">
<li>B: Begin flag.
</li>
<li>E: End flag.
</li>
<li>FragSequenceNumber: a 22-bit sequence number to identify the
            fragment.
</li>
</ul><p>
      
</p>
<a name="NDNFramePacking"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
NDN Frame Packing</h3>

<p>A sender/receiver pair may multiplex non-fragmentation
         frames on the same link.  For example, in NDN, there may be
         some NDNLP frames and some plain Interest or Data frames on
         the same link between the same pairs.  NDNLP frames are
         considered independently of other frames between the pair.
</p>
<p>NDNLP does not allow for frame packing: A frame contains
         only one out of the three Interest, Data and NDNLP packet
         types.
</p>
<a name="NDNxNumbers"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Assigned Numbers for NDN Begin-End fragmentation</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
           NDNLP-TYPE            0x64   // official, might change
           BEGIN-END-FIELD-TYPE  0x5c   // inofficial
           NDN-FRAGMENT-TYPE     0x52   // official, might change
</pre></div>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgements</h3>

<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>This document adds new values to the CCNx Packet Type Registry
        and CCNx Message Registry.
</p>
<a name="iana_packettype"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
CCNx Packet Type Registry</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Value    CCNx Packet Type                Definition
----     ------------------------        ----------
4        PT_FRAG                         See Section 4
</pre></div>
<a name="iana_message"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
CCNx Message Registry</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Value    CCNx Message Type               Definition
----     ------------------------        ----------
5        T_FRAGMENT                      See Section 4
16       T_FRAG_HEADER                   See Section 4
17       T_FRAG_RESET                    See Section 4
18       T_FRAG_RESET_ACK                See Section 4
</pre></div>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>This protocol has no security mechanisms and is vulnerable to
      injection attacks by other devices on the same physical link as
      the fragmentation peers.  One should use a secure Layer 2
      protocol, such as 802.1AE (MacSec) to prevent such attacks.
</p>
<a name="pseudocode"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Reset Pseudocode</h3>

<p>
<br /><hr class="insert" />
<a name="Reboot"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Procedure Reboot()
   N_LOCAL = (random number)
   N_REMOTE = FSN_LOCAL = FSN_REMOTE = 0
   State = (Init, Init)
   Send RESET(N_LOCAL)
   Start Timer
   state = (Sync, Init)
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
   
      
<br /><hr class="insert" />
<a name="ClearState"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Procedure ClearState(reset_num)
	N_REMOTE = reset_num
	FSN_LOCAL = 0
	FSN_REMOTE = 0
	Send RESETACK(N_REMOTE, N_LOCAL)
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<br /><hr class="insert" />
<a name="ReceiveReset"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Procedure ReceiveReset(reset_num)
   switch state
   case (Init, Init):
   case (Init, OK):
      N_REMOTE = reset_num
      Send RESETACK(N_REMOTE, N_LOCAL)
      break

   case (Sync, OK):
      If reset_num = N_REMOTE
         Send RESETACK(N_REMOTE, N_LOCAL)
      else
         Cancel Timer
         ClearState(reset_num)
         state = (Init, OK)
         break

   case (Sync, Init):
      N_REMOTE = reset_num
      Send RESETACK(N_REMOTE, N_LOCAL)
      state = (Sync, OK)
      break

   case (OK, OK):
      if reset_num = N_REMOTE
         Send RESETACK(N_REMOTE, N_LOCAL)
      else
         ClearState(reset_num)
         state = (Init, OK)
      break

   default:
      # Drop
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
  
      
<br /><hr class="insert" />
<a name="ReceiveResetAck"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Procedure ReceiveResetAck(ack_num, reset_num)
   switch state
   case (Sync, OK):
      if ack_num = N_LOCAL
         Cancel Timer
         Reset Timeout
         If reset_num = N_REMOTE
            State = (OK, OK)
         else
            ClearState()
            State = (Init, OK)
      break

   case (Sync, Init):
      If ack_num = N_LOCAL
         Cancel Timer
         Reset Timeout
         N_REMOTE = reset_num
         Send RESETACK(N_REMOTE, N_LOCAL)
         State = (OK, OK)
      break

   case (OK, OK):
      if ack_num = N_LOCAL
         if reset_num != N_REMOTE
            ClearState()
            State = (Init, OK)
      break

   default:
      # Drop
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
    
      
<br /><hr class="insert" />
<a name="Timeout"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Procedure Timeout()
   switch state:
   case (Sync, OK):
   case (Sync, Init):
      Increase Timeout
      Send RESET(N_LOCAL)
      Start Timer
      break
   default:
      # Ignore
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;9&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
         
	
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="http://www.rfc-editor.org/info/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, DOI&nbsp;10.17487/RFC2119, March&nbsp;1997.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CCNLite">[CCNLite]</a></td>
<td class="author-text">Mosko, M., Plass, M., and C. Tschudin, &ldquo;<a href="http://ccn-lite.net">CCN-Lite fragmentation</a>,&rdquo; Summer 2012.</td></tr>
<tr><td class="author-text" valign="top"><a name="CCNMessages">[CCNMessages]</a></td>
<td class="author-text">Mosko, M., Solis, I., and C. Wood, &ldquo;<a href="http://tools.ietf.org/html/draft-irtf-icnrg-ccnxmessages-03">CCNx Messages in TLV Format (Internet draft)</a>,&rdquo; 2016.</td></tr>
<tr><td class="author-text" valign="top"><a name="CCNx">[CCNx]</a></td>
<td class="author-text">PARC, Inc., &ldquo;<a href="http://www.ccnx.org">CCNx Open Source</a>,&rdquo; 2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="NDN">[NDN]</a></td>
<td class="author-text">&ldquo;<a href="http://www.named-data.net/wp-content/uploads/2013/11/packetformat.pdf">NDN specification Documentation, Release 0.1a2</a>,&rdquo; March&nbsp;2014.</td></tr>
<tr><td class="author-text" valign="top"><a name="NDNLP">[NDNLP]</a></td>
<td class="author-text">Shi, J. and B. Zhang, &ldquo;<a href="http://www.named-data.net/techreports.html">NDNLP: A Link Protocol for NDN</a>,&rdquo; NDN Technical Report&nbsp;NDN-0006, July&nbsp;2012.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1982">[RFC1982]</a></td>
<td class="author-text">Elz, R. and R. Bush, &ldquo;<a href="http://www.rfc-editor.org/info/rfc1982">Serial Number Arithmetic</a>,&rdquo; RFC&nbsp;1982, DOI&nbsp;10.17487/RFC1982, August&nbsp;1996.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1990">[RFC1990]</a></td>
<td class="author-text">Sklower, K., Lloyd, B., McGregor, G., Carr, D., and T. Coradetti, &ldquo;<a href="http://www.rfc-editor.org/info/rfc1990">The PPP Multilink Protocol (MP)</a>,&rdquo; RFC&nbsp;1990, DOI&nbsp;10.17487/RFC1990, August&nbsp;1996.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3552">[RFC3552]</a></td>
<td class="author-text">Rescorla, E. and B. Korver, &ldquo;<a href="http://www.rfc-editor.org/info/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>,&rdquo; BCP&nbsp;72, RFC&nbsp;3552, DOI&nbsp;10.17487/RFC3552, July&nbsp;2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5226">[RFC5226]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://www.rfc-editor.org/info/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;5226, DOI&nbsp;10.17487/RFC5226, May&nbsp;2008.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Marc Mosko</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">PARC</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Palo Alto, California  94304</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 650-812-4405</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:marc.mosko@parc.com">marc.mosko@parc.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Christian Tschudin</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University of Basel</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Basel  4051</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Switzerland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+41 61 267 0557</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:christian.tschudin@unibas.ch">christian.tschudin@unibas.ch</a></td></tr>
</table>
</body></html>
