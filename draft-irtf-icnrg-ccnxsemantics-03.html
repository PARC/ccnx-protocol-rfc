<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>CCNx Semantics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="CCNx Semantics">
<meta name="keywords" content="Content Centric Networking">
<meta name="generator" content="xml2rfc v1.35dev (http://xml.resource.org/)">
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: small; color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: small; font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: small; text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">ICNRG</td><td class="header">M. Mosko</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">PARC, Inc.</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">I. Solis</td></tr>
<tr><td class="header">Expires: December 19, 2016</td><td class="header">LinkedIn</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">C. Wood</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">PARC, Inc.</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">June 17, 2016</td></tr>
</table></td></tr></table>
<h1><br />CCNx Semantics<br />draft-irtf-icnrg-ccnxsemantics-03</h1>

<h3>Abstract</h3>

<p>This document describes the core concepts of the CCNx architecture and presents
        a minimum network protocol based on two messages: Interest, Content Object.
        It specifies the set of mandatory and optional fields within those messages
        and describes their behavior and interpretation. This architecture and protocol
        specification is independent of a specific wire encoding.
</p>
<p>The protocol also uses a Control message called an InterestReturn, whereby
        one system can return an Interest message to the previous hop due to an
        error condition.  It indicates to the previous hop that the current system will
        not respond to the Interest.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on December 19, 2016.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2016 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Requirements Language<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Protocol Overview<br />
<a href="#protocol">2.</a>&nbsp;
Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#grammar">2.1.</a>&nbsp;
Message Grammar<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#consumer">2.2.</a>&nbsp;
Consumer Behavior<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#publisher">2.3.</a>&nbsp;
Publisher Behavior<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#forwarder">2.4.</a>&nbsp;
Forwarder Behavior<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#hoplimit">2.4.1.</a>&nbsp;
Interest HopLimit<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#aggregation">2.4.2.</a>&nbsp;
Interest Aggregation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#contentstore">2.4.3.</a>&nbsp;
ContentStore Behavior<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#interest_pipe">2.4.4.</a>&nbsp;
Interest Pipeline<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#object_pipe">2.4.5.</a>&nbsp;
Content Object Pipeline<br />
<a href="#names">3.</a>&nbsp;
Names<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NameExamples">3.1.</a>&nbsp;
Name Examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ipid">3.2.</a>&nbsp;
Interest Payload ID<br />
<a href="#cachecontrol">4.</a>&nbsp;
Cache Control<br />
<a href="#ConObjHash">5.</a>&nbsp;
Content Object Hash<br />
<a href="#link">6.</a>&nbsp;
Link<br />
<a href="#hashes">7.</a>&nbsp;
Hashes<br />
<a href="#signature">8.</a>&nbsp;
Validation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#valalg">8.1.</a>&nbsp;
Validation Algorithm<br />
<a href="#matching">9.</a>&nbsp;
Interest to Content Object matching<br />
<a href="#InterestReturn">10.</a>&nbsp;
Interest Return<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#MessageFormat">10.1.</a>&nbsp;
Message Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#TypeDefinitions">10.2.</a>&nbsp;
ReturnCode Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#InterestReturnProtocol">10.3.</a>&nbsp;
Interest Return Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NoRoute">10.3.1.</a>&nbsp;
No Route<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#HopLimit">10.3.2.</a>&nbsp;
HopLimit Exceeded<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#MTU">10.3.3.</a>&nbsp;
Interest MTU Too Large<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NoResources">10.3.4.</a>&nbsp;
No Resources<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PathError">10.3.5.</a>&nbsp;
Path Error<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Prohibited">10.3.6.</a>&nbsp;
Prohibited<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Congestion">10.3.7.</a>&nbsp;
Congestion<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#UnsupportedHashAlgorithm">10.3.8.</a>&nbsp;
Unsupported Content Object Hash Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#MalformedInterest">10.3.9.</a>&nbsp;
Malformed Interest<br />
<a href="#Acknowledgements">11.</a>&nbsp;
Acknowledgements<br />
<a href="#IANA">12.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">13.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">14.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">14.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">14.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>This document describes the principles of the CCNx architecture. It describes the network protocol
        based on two message types: Interests and Content Objects.  The description is not
        dependent on a specific wire format or particular encodings.  This section introduces
        the main concepts of CCNx, which are further elaborated in the remainder of
        the document.
      
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Protocol Overview</h3>

<p>CCNx is a request/response protocol to fetch chunks of data based on a name.  Each
          chunk of data may be directly signed (e.g. RSA, EC) or protected by a message integrity check (MIC) or
          message authentication check (MAC), or indirectly protected via hash chains, or even unprotected.
          The identifying name is hierarchical and includes both a routable prefix and trailing application-dependent data.
          Because each chunk (or larger indirectly protected block) may provenance from a signature or MAC,
          we no longer need to rely on host identities, such as derived from TLS certificates, for
          data provenance.  In this sense, CCNx fundamentally protects the data; it does not
          rely on the pipe.  There are several options for data confidentiality, discussed later.
        
</p>
<p>As a request/response protocol, CCNx may be carried over many different transports.  In
          use today are Ethernet, TCP, UDP, 802.15.4, GTP, GRE, DTLS, TLS, and others.  While the
          specific wire format of CCNx may vary to some extent based on transport, the core principles and
          behaviors of CCNx outlined in this document should remain fixed.
        
</p>
<p>CCNx uses subjective names to identify bytes of payload.
          The Name combines a routable prefix with an arbitrary suffix assigned by the publisher to a piece of content.
          The result is a "named payload".
          This is different from other systems that use only self-certifying names, where the payload name is intrinsically
          derivable from the payload or its realization in a network object
          (e.g. a SHA-256 hash of the payload or network object).
          In human-readable form, we represent names as a <a class='info' href='#CCNxURI'>ccnx:<span> (</span><span class='info'>Mosko, M. and C. Wood, &ldquo;The CCNx URI Scheme (Internet draft),&rdquo; 2016.</span><span>)</span></a> [CCNxURI]
          scheme URI <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a>,
          though the canonical encoding should be octet strings.  In this respect, we speak of
          a name being made up of hierarchical path segments, which is the URI terminology.
        
</p>
<p>This document only defines the general properties of CCNx names.
          In some isolated environments, CCNx users may be able to use any name they choose and
          either inject that name (or prefix) in to a routing protocol or use other information foraging techniques.
          In the Internet environment, there will be policies around the formats of names and assignments of names
          to publishers, though those are not specified here.
        
</p>
<p>The key concept of CCNx is that a subjective name is bound to a fixed payload via
          cryptographic operations. This implies that the fact that a given publisher bound
          a certain subjective name to a certain
          payload can be verified via cryptographic means. For example, a publisher could
          use a cryptographic hash over the name and
          payload, sign the hash, and deliver the tuple {Name, Payload, Validation}.
          Additional information would be included as needed by specific
          validation mechanisms.  Therefore, we divide Validation in to a ValidationAlgorithm and
          a ValidationPayload.
          The ValidationAlgorithm
          has information about the crypto suite and parameters.  In particular, the ValidationAlgorithm
          usually has a field called KeyId which identifies the public key used by the validation,
          when applicable.
          The ValidationPayload is the output
          of the validation algorithm, such as a CRC value, an HMAC output, or an RSA signature.
        
</p>
<p>In addition to the essential Name, Payload, and Validation sections, a CCNx user may need
          to include some other signaling information.  This could include a hint about the type of
          Payload (e.g. application data, a cryptographic key, etc.) or cache control directives, etc.
          We will call this extra signaling information ExtraFields.
        
</p>
<p>A Named Payload is thus the tuple {{Name, ExtraFields, Payload, ValidationAlgorithm}, ValidationPayload},
          where all fields in the inner tuple are covered by the validation algorithm.
</p>
<p>CCNx specifies a network protocol around Interests (request messages) and Content Objects
          (response messages) to move named payloads.  An Interest
          includes the Name -- which identifies the desired response -- and two optional limiting restrictions.
          The first restriction on the KeyId and it limits responses to those signed with a
          ValidationAlgorithm KeyId field equal to the restriction.
          The second is the ContentObjectHash restriction.  It limits the response to one where the
          cryptographic hash of the entire named payload is equal to the restriction.
        
</p>
<p>The hierarchy of a CCNx Name is used for routing via the longest matching
          prefix in a Forwarder.  The longest matching prefix is computed name segment by
          name segment in the hierarchical path name, where each name segment must
          be exactly equal to match.
          There is no requirement that the prefix be globally routable.  Within
          a deployment any local routing may be used, even one that only uses
          a single flat (non-hierarchical) name segment.
        
</p>
<p>Another concept of CCNx is that there should be flow balance
          between Interest messages and Content Object messages.  At the network level,
          an Interest traveling along a single path should elicit no more than one
          Content Object response.  If some node sends the Interest along more than one
          path, that node should consolidate the responses such that only one
          Content Object flows back towards the requester.
          If an Interest is sent broadcast or multicast on a multiple-access media, the
          sender should be prepared for multiple responses unless some other media-dependent
          mechanism like gossip suppression or leader election is used.
        
</p>
<p>
          As an Interest travels the forward path following the Forwarding Information
          Base (FIB), it establishes state at each forwarder such that a Content Object
          response can trace its way back to the original requester(s) without the
          requester needing to include a routable return address.
          We use the notional Pending Interest Table (PIT) as a method to store state that
          facilitates the return of a Content Object.  The PIT table is not mandated by
          the specification.
        
</p>
<p>The notional PIT table stores the last hop of an Interest plus its Name
          and optional restrictions.  This is the data required to match a Content Object
          to an Interest (see <a class='info' href='#matching'>Section&nbsp;9<span> (</span><span class='info'>Interest to Content Object matching</span><span>)</span></a>).
          When a Content Object arrives, it must be matched against the PIT to determine
          which entries it satisfies.  For each such entry, at most one copy of the
          Content Object is sent to each listed last hop in the PIT entries.
        
</p>
<p>If multiple Interests with the same tuple {Name, KeyIdRestriction, ContentObjectHashRestriction}
          arrive at a node before a Content Object matching the first Interest comes back,
          they are grouped in the same PIT entry and their last hops aggregated (see <a class='info' href='#aggregation'>Section&nbsp;2.4.2<span> (</span><span class='info'>Interest Aggregation</span><span>)</span></a>).  
          Thus, one Content Object might satisfy multiple pending Interests.
        
</p>
<p>In CCNx, higher-layer protocols often become so-called "name-based protocols" because
          they operate on the CCNx Name.  For example, a versioning protocol might append additional
          name segments to convey state about the version of payload.  A content discovery protocol
          might append certain protocol-specific name segments to a prefix to discover content
          under that prefix.  Many such protocols may exist and apply their own rules to
          Names. They may be layered with each protocol encapsulating (to the left) a higher layer's Name prefix.
        
</p>
<p>This document also describes a control message called an InterestReturn.
          A network element may return an Interest message
          to a previous hop if there is an error processing the Interest. The returned Interest may be
          further processed at the previous hop or returned towards the Interest origin.
          When a node returns an Interest it indicates that the previous hop should not expect a response
          from that node for the Interest -- i.e. there is no PIT entry left at the returning node for
          a Content Object to follow.
        
</p>
<p>There are multiple ways to describe larger objects in CCNx.  Some options may use the namespace while
          others may use a structure such as a Manifest.  This document does not address these options at this time.
        
</p>
<p>The remainder of this document describes a named payload and the Interest/Content Object
          network protocol behavior in detail.
        
</p>
<a name="protocol"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Protocol</h3>

<p>CCNx is a request/response protocol, where a request is called an Interest
        and a response is called a ContentObject.  CCNx also uses a 1-hop control
        message called InterestReturn.  These are, as a group, called CCNx Messages.
</p>
<a name="grammar"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Message Grammar</h3>

<p>
          The CCNx message <a class='info' href='#RFC5234'>ABNF<span> (</span><span class='info'>Crocker, D., Ed. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5234] grammar is
          show in <a class='info' href='#abnfgrammar'>Figure&nbsp;1</a>.  The grammar does not include any
          encoding delimiters, such as TLVs.  Specific
          wire encodings are given in a separate document.  If a Validation section exists,
          the Validation Algorithm covers from the Body (BodyName or BodyOptName) through the
          end of the ValidationAlg section.  The InterestLifetime, CacheTime, and
          Return Code fields exist outside of the validation envelope and may be modified.
        
</p>
<p>The various fields -- in alphabetical order -- are defined as:
          </p>
<ul class="text">
<li>AbsTime: Absolute times are conveyed as the 64-bit UTC time in milliseconds
              since the epoch (standard POSIX time).
            
</li>
<li>CacheTime: The absolute time after which the publisher
              believes there is low value in caching the content object.  This is a recommendation
              to caches (see <a class='info' href='#cachecontrol'>Section&nbsp;4<span> (</span><span class='info'>Cache Control</span><span>)</span></a>).
            
</li>
<li>ConObjField: These are optional fields that may appear in a Content Object.
            
</li>
<li>ConObjHash: The value of the Content Object Hash, which is the SHA256-32 over
              the message from the beginning of the body to the end of the message.  Note that this
              coverage area is different from the ValidationAlg.  This value SHOULD NOT be trusted
              across domains (see <a class='info' href='#ConObjHash'>Section&nbsp;5<span> (</span><span class='info'>Content Object Hash</span><span>)</span></a>).
            
</li>
<li>ExpiryTime: An absolute time after which the 
              content object should be considered expired (see <a class='info' href='#cachecontrol'>Section&nbsp;4<span> (</span><span class='info'>Cache Control</span><span>)</span></a>).
            
</li>
<li>HopLimit: Interest messages may loop if there are loops in the forwarding plane.
              To eventually terminate loops, each Interest carries a HopLimit that is decremented
              after each hop and no longer forwarded when it reaches zero.  See <a class='info' href='#forwarder'>Section&nbsp;2.4<span> (</span><span class='info'>Forwarder Behavior</span><span>)</span></a>.
            
</li>
<li>InterestField: These are optional fields that may appear in an Interest
              message.
            
</li>
<li>KeyIdRestr: The KeyId Restriction.  A Content Object must have a KeyId with
              the same value as the restriction.
            
</li>
<li>ObjHashRestr: The Content Object Hash Restriction.  A content object must hash
              to the same value as the restriction using the same HashType.  The ObjHashRestr MUST
              use SHA256-32.
            
</li>
<li>KeyId: An identifier for the key used in the ValidationAlg.  For public key systems,
              this should be the SHA-256 hash of the public key.  For symmetric key systems, it
              should be an identifer agreed upon by the parties.
            
</li>
<li>KeyLink: A Link (see <a class='info' href='#link'>Section&nbsp;6<span> (</span><span class='info'>Link</span><span>)</span></a>) that names how to retrieve the key
              used to verify the ValidationPayload.  A message SHOULD NOT have both a KeyLink
              and a PublicKey.
            
</li>
<li>Lifetime: The approximate time during which a requester is willing to wait for
              a response, usually measured in seconds.  It is not strongly to the network round
              trip time, though it must be larger.
            
</li>
<li>Name: A name is made up of a non-empty first segment followed by zero or
              more additional segments, which may be of 0 length.  Path segments are opaque
              octet strings, and are thus case-sensitive if encoding UTF-8.
              An Interest MUST have a Name.  A ContentObject MAY have a Name (see <a class='info' href='#matching'>Section&nbsp;9<span> (</span><span class='info'>Interest to Content Object matching</span><span>)</span></a>).
            
</li>
<li>Payload: The message's data, as defined by PayloadType.
            
</li>
<li>PayloadType: The format of the Payload.  If missing, assume DataType.  DataType
              means the payload is opaque application bytes.  KeyType means the payload is
              a DER-encoded public key.  LinkType means it is a Link (see <a class='info' href='#link'>Section&nbsp;6<span> (</span><span class='info'>Link</span><span>)</span></a>).
            
</li>
<li>PublicKey: Some applications may wish to embed the public key used to
              verify the signature within the message itself.  The PublickKey is DER encoded.
              A message SHOULD NOT have both a KeyLink and a PublicKey.
            
</li>
<li>RelTime: A relative time, measured in milli-seconds.
            
</li>
<li>ReturnCode: States the reason an Interest message is being returned
              to the previous hop (see <a class='info' href='#TypeDefinitions'>Section&nbsp;10.2<span> (</span><span class='info'>ReturnCode Types</span><span>)</span></a>).
            
</li>
<li>SigTime: The absolute time (UTC milliseconds) when the signature was
              generated.
            
</li>
<li>Hash: Hash values carried in a Message carry a HashType to identify the algorithm
              used to generate the hash followed by the hash value.  This form is to allow
              hash agility.  Some fields may mandate a specific HashType.
            
</li>
</ul><p>
        
</p><br /><hr class="insert" />
<a name="abnfgrammar"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Message       := Interest / ContentObject / InterestReturn
Interest      := HopLimit [Lifetime] BodyName [Validation]
ContentObject := [CacheTime / ConObjHash] BodyOptName [Validation]
InterestReturn:= ReturnCode Interest
BodyName      := Name Common
BodyOptName   := [Name] Common
Common        := *Field [Payload]
Validation    := ValidationAlg ValidatonPayload

Name          := FirstSegment *Segment
FirstSegment  := 1* OCTET
Segment       := 0* OCTET

ValidationAlg := RSA-SHA256 HMAC-SHA256 CRC32C
ValidatonPayload := 1* OCTET
RSA-SHA256    := KeyId [PublicKey] [SigTime] [KeyLink]
HMAC-SHA256   := KeyId [SigTime] [KeyLink]
CRC32C        := [SigTime]

AbsTime       := 8 OCTET ; 64-bit UTC msec since epoch
CacheTime     := AbsTime
ConObjField   := ExpiryTime / PayloadType
ConObjHash    := Hash ; The Content Object Hash
DataType      := "1"
ExpiryTime    := AbsTime
Field         := InterestField / ConObjField
Hash          := HashType 1* OCTET
HashType      := SHA256-32 / SHA512-64 / SHA512-32
HopLimit      := OCTET
InterestField := KeyIdRestr / ObjHashRestr
KeyId         := 1* OCTET ; key identifier
KeyIdRestr    := 1* OCTET
KeyLink       := Link
KeyType       := "2"
Lifetime      := RelTime
Link          := Name [KeyIdResr] [ObjHashRestr]
LinkType      := "3"
ObjHashRestr  := Hash
Payload       := *OCTET
PayloadType   := DataType / KeyType / LinkType
PublicKey     := ; DER-encoded public key
RelTime       := 1* OCTET ; msec
ReturnCode    := ; see Section ZZZ
SigTime       := AbsTime
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="consumer"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Consumer Behavior</h3>

<p>To request a piece of content for a given {Name, [KeyIdRest], [ObjHashRestr]},
          a consumer creates an Interest message with those values.  It MAY add a validation
          section, typically only a CRC32C.  If a consumer uses a MAC or a signature, it
          SHOULD include a name component to signify the signature and prevent the Interest
          from being aggregated with other Interests or satisfied by a Content Object that
          has no relation to the validation.
        
</p>
<p>A consumer MAY put a Payload field in an Interest to send additional data
          to the producer beyond what is in the Name.  The Name is used for routing and
          may be rememberd at each hop in the notional PIT table to facilitate returning
          a content object, so storing large amounts of state in the Name could lead to
          high memory requirements.  Because the Payload is not considered when forwarding
          an Interest or matching a Content Object to an Interest, a consumer SHOULD put
          an Interest Payload ID (see <a class='info' href='#ipid'>Section&nbsp;3.2<span> (</span><span class='info'>Interest Payload ID</span><span>)</span></a>) as part of the name to
          allow a forwarder to match Interests to content objects and avoid aggregating
          Interests with different payloads.
        
</p>
<p>The consumer SHOULD specify an InterestLifetime, which is the length of time
          the consumer is willing to wait for a response.  The InterestLifetime is an
          application-scale time, not a network round trip time (see <a class='info' href='#aggregation'>Section&nbsp;2.4.2<span> (</span><span class='info'>Interest Aggregation</span><span>)</span></a>).
          If not present, the InterestLifetime will use a default value (TO_INTERESTLIFETIME).
        
</p>
<p>The consumer SHOULD set the Interest HopLimit to a reasonable value, or use
           the default 255.  If the consumer knows the distances to the producer via
          routing, it SHOULD use that value.
        
</p>
<p>A consumer hands off the Interest to its first forwarder, which will convey
          the Interest over the network to a publisher (or replica) that may satisfy it
          based on the name (see <a class='info' href='#forwarder'>Section&nbsp;2.4<span> (</span><span class='info'>Forwarder Behavior</span><span>)</span></a>).
        
</p>
<p>Interest messages are unreliable.  A consumer SHOULD run a transport protocol
          that will retry the Interest if it goes unanswered, up to the InterestLifetime.
          No transport protocol is specified in this document.
        
</p>
<p>The network MAY send to the consumer an InterestReturn message that indicates the
          network cannot fulfill the Interest.  The ReturnCode specifies the reason for the
          failure, such as no route or congestion.  Depending on the ReturnCode, the consumer
          MAY retry the Interest or MAY return an error to the requesting application.
        
</p>
<p>If the content was found and returned by the first forwarder, the
          consumer will receive a ContentObject.  The consumer SHOULD:
          </p>
<ul class="text">
<li>Ensure the content object is properly formatted.
            
</li>
<li>Verify that the returned Name matches a pending request.  If the request
              also had KeyIdRestr and ObjHashRest, it should also validate those properties.
            
</li>
<li>If the content object is signed, it should cryptographically verify the signature.
              If it does not have the corresponding key, it SHOULD fetch the key, such as from
              a key resolution service or via the KeyLink.
            
</li>
<li>If the signature has a SigTime, the consumer MAY use that in considering
              if the signature is valid.  For example, if the consumer is asking for dynamically
              generated content, it should expect the SigTime to not be before the time
              the Interest was generated.
            
</li>
<li>If the content object is signed, it should assert the trustworthiness of the
              signing key to the namespace.  Such an assertion is beyond the scope of this
              document, though one may use traditional PKI methods,
              a trusted key resolution service, or methods like [schematized trust].
            
</li>
<li>It MAY cache the content object for future use, up to the ExpiryTime
              if present.
            
</li>
<li>A consumer MAY accept a content object off the wire that is expired.
              It may happen that a packet expires while in flight, and there is no requirement
              that forwarders drop expired packets in flight.  The only requirement is that
              content stores or caches or producers not respond with an expired content object.
            
</li>
</ul><p>
        
</p>
<a name="publisher"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Publisher Behavior</h3>

<p> This document does not specify the method by which names populate a Forwarding
          Information Base (FIB) table at forwarders (see <a class='info' href='#forwarder'>Section&nbsp;2.4<span> (</span><span class='info'>Forwarder Behavior</span><span>)</span></a>).
          A publisher is either configured with one or more name prefixes under which it may
          create content, or it chooses its name prefixes and informs the routing layer to advertise
          those prefixes.
        
</p>
<p>When a publisher receives an Interest, it SHOULD:
          </p>
<ul class="text">
<li>Verify that the Interest is part of the publishers namespace(s).
            
</li>
<li>If the Interest has a Validation section, verify the ValidationPayload.
              Usually an Interest will only have a CRC32C unless the publisher application
              specifically accommodates other validations.
              The publisher MAY choose to drop Interests that carry a Validation section if
              the publisher application does not expect those signatures as this could be
              a form of computational denial of service.  If the signature requires a key
              that the publisher does not have, it is NOT RECOMMENDED that the publisher fetch
              the key over the network, unless it is part of the application's expected behavior.
            
</li>
<li>Retrieve or generate the requested content object and return it to the
              Interest's previous hop.  If the requested content cannot be returned,
              the publisher SHOULD reply with an InterestReturn or a content object with
              application payload that says the content is not available; this content object
              should have a short ExpiryTime in the future.
            
</li>
</ul><p>
        
</p>
<a name="forwarder"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Forwarder Behavior</h3>

<p>A forwarder routes Interest messages based on a Forwarding Information Base (FIB),
          returns Content Objects that match Interests to the Interest's previous hop, and
          processed InterestReturn control messages.  It may also keep a cache of Content Objects
          in the notional Content Store table.  This document does not specify the internal behavior
          of a forwarder, only these and other external behaviors.
        
</p>
<p>In this document, we will use two processing pipelines, one for Interests
          and one for Content Objects.  Interest processing is made up of checking for
          duplicate Interests in the PIT (see <a class='info' href='#aggregation'>Section&nbsp;2.4.2<span> (</span><span class='info'>Interest Aggregation</span><span>)</span></a>), checking
            for a cached Content Object in the Content Store (see <a class='info' href='#contentstore'>Section&nbsp;2.4.3<span> (</span><span class='info'>ContentStore Behavior</span><span>)</span></a>),
            and forwarding an Interest via the FIB.  Content Store processing is made up
            of checking for matching Interests in the PIT and forwarding to those previous hops.
        
</p>
<a name="hoplimit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4.1"></a><h3>2.4.1.&nbsp;
Interest HopLimit</h3>

<p>Interest looping is not prevented in CCNx. An Interest traversing loops is eventually
            discarded using the hop-limit field of the Interest, which is decremented at each hop
            traversed by the Interest.
          
</p>
<p>Every Interest MUST carry a HopLimit.
          
</p>
<p>When an Interest is received from another forwarder, the HopLimit MUST
            be positive.  It MUST be decremented by at least 1.
          
</p>
<p>If the HopLimit equals 0, the Interest MUST NOT be forwarded to another forwarder; 
            it MAY be sent to a publisher application or serviced from a local Content Store.
          
</p>
<a name="aggregation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4.2"></a><h3>2.4.2.&nbsp;
Interest Aggregation</h3>

<p>Interest aggregation is when a forwarder receives an Interest message that
              could be satisfied by another Interest message already forwarded by the node so the
              forwarder suppresses the new Interest; it only records the additional previous hop
              so a Content Object sent in response to the first Interest will satisfy both Interests.
          
</p>
<p>CCNx uses an interest aggregation rule that assumes the InterestLifetime is 
               akin to a subscription time and is not a network round trip time.  Some previous
               aggregation rules assumed the lifetime was a round trip time, but this leads to
               problems of expiring an Interest before a response comes if the RTT is estimated
               too short or interfering with an ARQ scheme that wants to re-transmit an Interest
               but a prior interest over-estimated the RTT.
          
</p>
<p>A forwarder MAY implement an Interest aggregation scheme.  If it does not, then
               it will forward all Interest messages.  This does not imply that multiple,
               possibly identical, Content Objects will come back.  A forwarder MUST still
               satisfy all pending Interests, so one Content Object could satisfy multiple
               similar interests, even if the forwarded did not suppress duplicate Interest
               messages.
          
</p>
<p>A RECOMMENDED Interest aggregation scheme is:
            </p>
<ul class="text">
<li>Two Interests are considered 'similar' if they have the same Name, KeyIdRestr, and ObjHashRestr.
          
</li>
<li>Let the notional value InterestExpiry (a local value at the forwarder) be equal to
               the receive time plus the InterestLifetime (or a platform-dependent default value if not present).
          
</li>
<li>An Interest record (PIT entry) is considered invalid if its InterestExpiry time is in the past.
          
</li>
<li>The first reception of an Interest MUST be forwarded.
          
</li>
<li>A second or later reception of an Interest similar to a valid pending Interest
               from the same previous hop MUST be forwarded.  We consider these a retransmission request.
          
</li>
<li>A second or later reception of an Interest similar to a valid pending Interest 
            from a new previous hop MAY be aggregated (not forwarded).
          
</li>
<li>Aggregating an Interest MUST extend the InterestExpiry time of the Interest record.
               An implementation MAY keep a single InterestExpiry time for all previous hops
               or MAY keep the InterestExpiry time per previous hop.  In the first case, the forwarder
               might send a ContentObject down a path that is no longer waiting for it, in which case
               the previous hop (next hop of the Content Object) would drop it.
          
</li>
</ul><p>
          
</p>
<a name="contentstore"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4.3"></a><h3>2.4.3.&nbsp;
ContentStore Behavior</h3>

<p>The ContentStore is a special cache that sits on the fast path of a CCNx forwarder.
            It is an optional component.  It serves to repair lost packets and handle flash requests
            for popular content.  It could be pre-populated or use opportunistic caching.
            Because the Content Store could serve to amplify an attach via cache poisoning, there
            are special rules about how a Content Store behaves.
            </p>
<ol class="text">
<li>A forwarder MAY implement a ContentStore.  If it does, the Content Store
                matches a Content Object to an Interest via the normal matching rules (see <a class='info' href='#matching'>Section&nbsp;9<span> (</span><span class='info'>Interest to Content Object matching</span><span>)</span></a>).
              
</li>
<li>If an Interest has a KeyIdRestr, then the ContentStore MUST NOT reply unless it knows
                the signature on the matching ContentObject is correct.  It may do this by external knowledge
                (i.e. in a managed system pre-populating the cachine) or by having the public key and
                cryptographically verifying the signature.  If the public key is provided in the ContentObject
                itself (i.e. in the PublicKey field) or in the Interest, the ContentStore MUST verify that
                the public key's SHA-256 hash is equal to the KeyId and that it verifies the signature.
                A ContentStore SHOULD NOT fetch keys over the
                network.  If it cannot verify the signature, it should treat the Interest as a cache miss.
              
</li>
<li>If an Interest has an ObjHashRestr, then the ContentStore MUST NOT reply unless it
                knows the the matching ContentObject has the correct hash.  If it cannot verify the
                hash, then it should treat the Interest as a cache miss.
              
</li>
<li>It must object the Cache Control directives (see <a class='info' href='#cachecontrol'>Section&nbsp;4<span> (</span><span class='info'>Cache Control</span><span>)</span></a>).
              
</li>
</ol><p>
          
</p>
<a name="interest_pipe"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4.4"></a><h3>2.4.4.&nbsp;
Interest Pipeline</h3>

<p>
            </p>
<ol class="text">
<li>Perform the hoplimit check (see <a class='info' href='#hoplimit'>Section&nbsp;2.4.1<span> (</span><span class='info'>Interest HopLimit</span><span>)</span></a>).
              
</li>
<li>Determine if the Interest can be aggregated, as per <a class='info' href='#aggregation'>Section&nbsp;2.4.2<span> (</span><span class='info'>Interest Aggregation</span><span>)</span></a>.  If
                it can be, aggregate and do not forward the Interest.
              
</li>
<li>If forwarding the Interest, check for a hit in the Content Store, as
                per <a class='info' href='#contentstore'>Section&nbsp;2.4.3<span> (</span><span class='info'>ContentStore Behavior</span><span>)</span></a>.  If a matching
                Content Object is found, return it to the Interest's previous hop.  This
                injects the ContentStore as per <a class='info' href='#object_pipe'>Section&nbsp;2.4.5<span> (</span><span class='info'>Content Object Pipeline</span><span>)</span></a>.
              
</li>
<li>Lookup the Interest in the FIB.  The longest prefix match (LPM) is performed
                name segment by name segment (not byte or bit).  It should exclude the
                Interest's previous hop.  If a match is found, forward the Interest.
                If no match is found or the forwarder choses to not forward due to
                a local condition (e.g. congestion), it SHOULD send an InterestReturn
                message, as per <a class='info' href='#InterestReturn'>Section&nbsp;10<span> (</span><span class='info'>Interest Return</span><span>)</span></a>.
</li>
</ol><p>
          
</p>
<a name="object_pipe"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4.5"></a><h3>2.4.5.&nbsp;
Content Object Pipeline</h3>

<p>
            </p>
<ol class="text">
<li>It is RECOMMENDED that a forwarder that receives a content object
                check that the ContentObject came from an expected previous hop.  An
                expected previous hop is one pointed to by the FIB or one recorded in the
                PIT as having had a matching Interest sent that way.
              
</li>
<li>A Content Object MUST be matched to all pending Interests that
                satisfy the matching rules (see <a class='info' href='#matching'>Section&nbsp;9<span> (</span><span class='info'>Interest to Content Object matching</span><span>)</span></a>).  Each statisfied
                pending Interest MUST then be removed from the set of pending Interests.
              
</li>
<li>A forwarder SHOULD NOT send more then one copy of the received
                Content Object to the same Interest previous hop.  It may happen, for example,
                that two Interest ask for the same Content Object different ways (e.g. by name
                and by name an keyid) and that they both come from the same previous hop.
                It is normal to send
                the same content object multiple times on the same interface, such as Ethernet,
                if it is going to different previous hops.
              
</li>
<li>A Content Object SHOULD only be put in the Content Store if it satisfied
                an Interest (and passed rule #1 above).  This is to reduce the chances
                of cache poisoning.
              
</li>
</ol><p>
          
</p>
<a name="names"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Names</h3>

<p>A CCNx name is a composition of name segments. Each name segment carries a label
        identifying the purpose of the name segment, and a value.  For example, some
        name segments are general names and some serve specific purposes, such as carrying
        version information or the sequencing of many chunks of a large object into smaller,
        signed Content Objects.
</p>
<p>The name segment labels specified in this document are given in the table below.
        Name Segment is a general name segment, typically occurring in the
        routable prefix and user-specified content name.  Other segment types are for
        functional name components that imply a specific purpose.
      
</p>
<p>A forwarding table entry may contain name segments of any type.
        Routing protocol policy and local system policy may limit what goes into
        forwarding entries, but there is no restriction at the core level.
        An Interest routing protocol, for example, may only allow binary name segments.
        A load balancer or compute cluster
        may route through additional component types, depending on their services.
      
</p><br /><hr class="insert" />
<a name="name_types"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="left">
<tr><th align="center">Name</th><th align="left">Description</th></tr>
<tr>
<td align="center">Name Segment</td>
<td align="left">A generic name segment that includes arbitrary octets.</td>
</tr>
<tr>
<td align="center">Interest Payload ID</td>
<td align="left">An octet string that identifies the payload carried in an Interest. As an example, the Payload ID might be a hash of the Interest Payload.
          This provides a way to differentiate between Interests based on the Payload solely through a Name Segment without having to include
          all the extra bytes of the payload itself. </td>
</tr>
<tr>
<td align="center">Application Components</td>
<td align="left">An application-specific payload in a name segment.  An application may apply
          its own semantics to these components.  A good practice is to identify the
          application in a Name segment prior to the application component segments.</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1: CCNx Name Segment Types&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>At the lowest level, a Forwarder does not need to understand the semantics
        of name segments; it need only identify name segment boundaries and
        be able to compare two name segments (both label and value) for equality.  The Forwarder
        matches paths segment-by-segment against
        its forwarding table to determine a next hop.
</p>
<a name="NameExamples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Name Examples</h3>

<p>This section uses the <a class='info' href='#CCNxURI'>CCNx URI<span> (</span><span class='info'>Mosko, M. and C. Wood, &ldquo;The CCNx URI Scheme (Internet draft),&rdquo; 2016.</span><span>)</span></a> [CCNxURI] representation of CCNx names .
</p><br /><hr class="insert" />
<a name="name_examples"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="left">
<tr><th align="center">Name</th><th align="left">Description</th></tr>
<tr>
<td align="center">ccnx:/</td>
<td align="left">A 0-length name, corresponds to a default route.</td>
</tr>
<tr>
<td align="center">ccnx:/NAME=</td>
<td align="left">A name with 1 segment of 0 length, distinct from ccnx:/.</td>
</tr>
<tr>
<td align="center">ccnx:/NAME=foo/APP:0=bar</td>
<td align="left">A 2-segment name, where the first segment is of type NAME and the second
            segment is of type APP:0.</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 2: CCNx Name Examples&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="ipid"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Interest Payload ID</h3>

<p>An Interest may also have a Payload which carries state about the Interest but is not used to match
          a Content Object.
          If an Interest contains a payload, the Interest name should contain an Interest Payload ID (IPID).
          The IPID allows a PIT table entry to correctly multiplex Content Objects in response to a specific Interest with
          a specific payload ID.  The IPID could be derived from a hash of the payload or could be a GUID or a nonce.
          An optional Metadata field defines the IPID field so other systems could verify the IPID, such as when it is
          derived from a hash of the payload.  No system is required to verify the IPID.
        
</p>
<a name="cachecontrol"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Cache Control</h3>

<p>CCNx supports two fields that affect cache control.  These determine how a
        cache or Content Store handles a Content Object.  They are not used in the fast path,
        but only to determine if a ContentObject can be injected on to the fast path in response
        to an Interest.
      
</p>
<p>The ExpiryTime is a field that exists within the signature envelope of a Validation Algorithm.
        It is the UTC time in milliseconds after which the ContentObject is considered expired and MUST
        no longer be used to respond to an Interest from a cache.
      
</p>
<p>The Recommended Cache Time (RCT) is a field that exists outside the signature envelope.
        It is the UTC time in milliseconds after which the publisher considers the Content Object to be
        of low value to cache.  A cache SHOULD discard it after the RCT, though it MAY keep it and still
        respond with it.  A cache is MAY discard the content object before the RCT time too; there is
        no contractual obligaton to remember anything.
      
</p>
<p>This formulation allows a producer to create a Content Object with a long ExpiryTime
        but short RCT and keep re-publishing the same, signed, Content Object over and over again
        by extending the RCT.  This allows a form of "phone home" where the publisher wants to
        periodically see that the content is being used.
      
</p>
<a name="ConObjHash"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Content Object Hash</h3>

<p>CCNx allows an Interest to restrict a response to a specific hash.  The hash covers the
          message body and the validation section, thus it is specific to a given signature.  Because
          it is part of the matching rules (see <a class='info' href='#matching'>Section&nbsp;9<span> (</span><span class='info'>Interest to Content Object matching</span><span>)</span></a>), the hash is used at every hop.
        
</p>
<p>There are two options for matching the content object hash restriction in an Interest.
          First, a forwarder could compute for itself the hash value and compare it to the restriction.
          This is an expensive operation.  The second option is for a border device to compute the hash
          once and place the value in a header (ConObjHash) that is carried through the network.  The second
          option, of course, removes any security properties from matching the hash, so SHOULD only be
          used within a trusted domain.  The header SHOULD be removed when crossing a trust boundary.
</p>
<a name="link"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Link</h3>

<p>A Link is the tuple {Name, KeyId, ContentObjectHashRestriction}.  The information in a Link comprises the fields
        the fields of an Interest which would retrieve the Link target.
        A Content Object with PayloadType = "Link" is an object whose payload is a Link.
        This tuple may be used as a KeyName to identify
        a specific object with the certificate wrapped key.
      
</p>
<a name="hashes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Hashes</h3>

<p>Several protocol fields use cryptographic hash functions, which must be secure against attack
        and collisions.  Because these hash functions change over time, which better ones appearing
        and old ones falling victim to attacks, it is important that a CCNx protocol implementation support
        hash agility.
</p>
<p>In this document, we suggest certain hashes (e.g. SHA-256), but a specific
        implementation may use what it deems best.  The normative <a class='info' href='#CCNMessages'>CCNx Messages<span> (</span><span class='info'>Mosko, M. and I. Solis, &ldquo;CCNx Messages in TLV Format (Internet draft),&rdquo; 2016.</span><span>)</span></a> [CCNMessages]
        specification should be taken as the definition of acceptable hash functions and uses.
      
</p>
<a name="signature"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Validation</h3>

<a name="valalg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Validation Algorithm</h3>

<p>The Validator consists of a ValidationAlgorithm that specifies how to verify the message
          and a ValidationPayload containing the validation output. The ValidationAlgorithm
          section defines the type of algorithm to use and includes any necessary additional information.
          The validation is calculated from the beginning of the CCNx Message through the end of the
          ValidationAlgorithm section.  The ValidationPayload is the actual cryptographic bytes, such
          as a CRC value or an HMAC value or a signature value.
</p>
<p>
          Some Validators contain a KeyId,
          identifying the publisher authenticating the Content Object. If an Interest carries
          a KeyIdRestriction, then that KeyIdRestriction MUST exactly match the Content Object's KeyId.
</p>
<p>
          Validation Algorithms fall into three categories: MICs, MACs, and Signatures.  Validators using MIC algorithms
          do not need to provide any additional information; they may be computed and verified
          based only on the algorithm (e.g. CRC32C). MAC validators require the use of a KeyId
          identifying the secret key used by the authenticator. Because MACs are usually used between two parties that
          have already exchanged secret keys via a key exchange protocol, the KeyId may be any agreed-upon value to
          identify which key is used.  Signature
          validators use public key cryptography such as RSA, DSA, or Elliptical Curve (EC). The KeyId field in the
          ValidationAlgorithm identifies the public key used to verify the signature. A signature may optionally
          include a KeyLocator, as described above, to bundle a Key or Certificate or KeyName.  MAC and Signature
          validators may also include a SignatureTime, as described above.
        
</p>
<p>A PublicKeyLocator KeyName points to a Content Object with an X509 certificate
          in the payload.  In this case, the target KeyId must equal the first object's KeyId.
          The target KeyLocator must include the public key corresponding to the KeyId.
          That key must validate the target Signature.
          The payload is an X.509 certificate whose public key must match the target
          KeyLocator's key.  It must be issued by a trusted authority, preferably specifying
          the valid namespace of the key in the distinguished name.
        
</p>
<a name="matching"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Interest to Content Object matching</h3>

<p>A Content Object satisfies an Interest if and only if (a) the Content Object name, if given,
        exactly matches the Interest name, and (b) the ValidationAlgorithm KeyId of the Content Object
        exactly equals the Interest KeyIdRestriction, if given, and (c) the computed ContentObjectHash exactly equals the Interest
        ContentObjectHashRestriction, if given.
</p>
<p>The matching rules are given by this predicate, which if it evaluates true means
        the ContentObject matches the Interest.
        Ni = Name in Interest (may not be empty), Ki = KeyIdRestriction
        in the interest (may be empty), Hi = ContentObjectHashRestriction in Interest (may be empty).
        Likewise, No, Ko, Ho are those properties in the ContentObject, where No and Ko may be empty;
        Ho always exists.
        For binary relations, we use &amp; for AND and | for OR.  We use E for the EXISTS (not empty)
        operator and ! for the NOT EXISTS operator.
</p>
<p>As a special case, if the ContentObjectHashRestriction in the Interest specifies an
        unsupported hash algorithm, then no ContentObject can match the Interest so the
        system should drop the Interest and MAY send an InterestReturn to the previous hop.
        In this case, the predicate below will never get executed because the Interest is
        never forwarded.  If the system is using the optional behavior of having a different system
        calculate the hash for it, then the system may assume all hash functions are
        supported and leave it to the other system to accept or reject the Interest.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
(!No | (Ni=No)) &amp; (!Ki | (Ki=Ko)) &amp; (!Hi | (Hi=Ho)) &amp; (E No | E Hi)
</pre></div>
<p>As one can see, there are two types of attributes one can match.  The first term
        depends on the existence of the attribute in the ContentObject while the next two terms
        depend on the existence of the attribute in the Interest.  The last term
        is the Nameless Object restriction that if a Content Object does not have a Name, then
        it must match the Interest on at least the Hash restriction.
</p>
<p>If a Content Object does not carry the ContentObjectHash
        as an expressed field, it must be calculated in network to match against. It is
        sufficient within an autonomous system to calculate a ContentObjectHash
        at a border router and carry it via trusted means within the autonomous
        system. If a Content Object ValidationAlgorithm does not have a KeyId then
        the Content Object cannot match an Interest with a KeyIdRestriction.
</p>
<a name="InterestReturn"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Interest Return</h3>

<p>This section describes the process whereby a network element may return an Interest message
        to a previous hop if there is an error processing the Interest. The returned Interest may be
        further processed at the previous hop or returned towards the Interest origin.
        When a node returns an Interest it indicates that the previous hop should not expect a response
        from that node for the Interest -- i.e. there is no PIT entry left at the returning node.
</p>
<p>The returned message maintains compatibility with the existing TLV packet format
        (a fixed header, optional hop-by-hop headers, and the CCNx message body). The returned Interest
        packet is modified in only two ways: 
        </p>
<ul class="text">
<li>The PacketType is set to InterestReturn to indicate a Feedback message.
          
</li>
<li>The ReturnCode is set to the appropriate value to signal the reason for the return
          
</li>
</ul><p>
      
</p>
<p>The specific encodings of the Interest Return are specified in <a class='info' href='#CCNMessages'>[CCNMessages]<span> (</span><span class='info'>Mosko, M. and I. Solis, &ldquo;CCNx Messages in TLV Format (Internet draft),&rdquo; 2016.</span><span>)</span></a>.
</p>
<p>A Forwarder is not required to send any Interest Return messages.
</p>
<p>A Forwarder is not required to process any received Interest Return message.
        If a Forwarder does not process Interest Return messages, it should silently drop them.
</p>
<p>The Interest Return message does not apply to a Content Object or any other message type.
</p>
<p>An Interest Return message is a 1-hop message between peers.  It is not propagated
        multiple hops via the FIB.  An intermediate node that receives an InterestReturn may
        take corrective actions or may propagate its own InterestReturn to previous hops
        as indicated in the reverse path of a PIT entry.
</p>
<a name="MessageFormat"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
Message Format</h3>

<p>The Interest Return message looks exactly like the original Interest message with the
          exception of the two modifications mentioned above.
          The PacketType is set to indicate the message is an InterestReturn and the reserved
          byte in the Interest header is used as a Return Code.  The numeric values for the PacketType
          and ReturnCodes are in <a class='info' href='#CCNMessages'>[CCNMessages]<span> (</span><span class='info'>Mosko, M. and I. Solis, &ldquo;CCNx Messages in TLV Format (Internet draft),&rdquo; 2016.</span><span>)</span></a>.
</p>
<a name="TypeDefinitions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
ReturnCode Types</h3>

<p>This section defines the InterestReturn ReturnCode introduced in this RFC.
          The numeric values used in the packet are defined in <a class='info' href='#CCNMessages'>[CCNMessages]<span> (</span><span class='info'>Mosko, M. and I. Solis, &ldquo;CCNx Messages in TLV Format (Internet draft),&rdquo; 2016.</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="ReasonCode"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Name</th><th align="left">Description</th></tr>
<tr>
<td align="left">
            <a class='info' href='#NoRoute'>No Route<span> (</span><span class='info'>No Route</span><span>)</span></a>
          </td>
<td align="left">The returning Forwarder has no route to the Interest name.</td>
</tr>
<tr>
<td align="left">
            <a class='info' href='#HopLimit'>HopLimit Exceeded<span> (</span><span class='info'>HopLimit Exceeded</span><span>)</span></a>
          </td>
<td align="left">The HopLimit has decremented to 0 and need to forward the packet.</td>
</tr>
<tr>
<td align="left">
            <a class='info' href='#MTU'>Interest MTU too large<span> (</span><span class='info'>Interest MTU Too Large</span><span>)</span></a>
          </td>
<td align="left">The Interest's MTU does not conform to the required minimum and would require fragmentation.</td>
</tr>
<tr>
<td align="left">
            <a class='info' href='#NoResources'>No Resources<span> (</span><span class='info'>No Resources</span><span>)</span></a>
          </td>
<td align="left">The node does not have the resources to process the Interest.</td>
</tr>
<tr>
<td align="left">
            <a class='info' href='#PathError'>Path error<span> (</span><span class='info'>Path Error</span><span>)</span></a>
          </td>
<td align="left">There was a transmission error when forwarding the Interest along a route (a transient error).</td>
</tr>
<tr>
<td align="left">
            <a class='info' href='#Prohibited'>Prohibited<span> (</span><span class='info'>Prohibited</span><span>)</span></a>
          </td>
<td align="left">An administrative setting prohibits processing this Interest.</td>
</tr>
<tr>
<td align="left">
            <a class='info' href='#Congestion'>Congestion<span> (</span><span class='info'>Congestion</span><span>)</span></a>
          </td>
<td align="left">The Interest was dropped due to congestion (a transient error).</td>
</tr>
<tr>
<td align="left">
            <a class='info' href='#UnsupportedHashAlgorithm'>Unsupported Content Object Hash Algorithm<span> (</span><span class='info'>Unsupported Content Object Hash Algorithm</span><span>)</span></a>
          </td>
<td align="left">The Interest was dropped because it requested a Content Object Hash Restriction using
            a hash algorithm that cannot be computed.</td>
</tr>
<tr>
<td align="left">
            <a class='info' href='#MalformedInterest'>Malformed Interest<span> (</span><span class='info'>Malformed Interest</span><span>)</span></a>
          </td>
<td align="left">The Interest was dropped because it did not correctly parse.</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 3: Interest Return Reason Codes&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="InterestReturnProtocol"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
Interest Return Protocol</h3>

<p>This section describes the Forwarder behavior for the various Reason codes for Interest Return.
          A Forwarder is not required to generate any of the codes, but if it does, it must conform to
          this specification.
</p>
<p>If a Forwarder receives an Interest Return, it SHOULD take these standard corrective actions.
          A forwarder is allowed to ignore Interest Return messages, in which case its PIT entry would
          go through normal timeout processes.
          
          </p>
<ul class="text">
<li>Verify that the Interest Return came from a next-hop to which it actually sent the Interest.
</li>
<li>If a PIT entry for the corresponding Interest does not exist, the Forwarder should ignore the Interest Return.
</li>
<li>If a PIT entry for the corresponding Interest does exist, the Forwarder MAY do one of the following:
              
<ul class="text">
<li>Try a different forwarding path, if one exists, and discard the Interest Return, or
</li>
<li>Clear the PIT state and send an Interest Return along the reverse path.
</li>
</ul>
            
</li>
</ul><p>
        
</p>
<p>If a forwarder tries alternate routes, it MUST ensure that it does not use
          same same path multiple times.  For example, it could keep track of which next hops it has
          tried and not re-use them.
</p>
<p>If a forwarder tries an alternate route, it may receive a second InterestReturn, possibly of
          a different type than the first InterestReturn.  For example, node A sends an Interest to node B,
          which sends a No Route return.  Node A then tries node C, which sends a Prohibited.  Node A
          should choose what it thinks is the appropriate code to send back to its previous hop
</p>
<p>If a forwarder tries an alternate route, it should decrement the Interest Lifetime to account
          for the time spent thus far processing the Interest.
</p>
<a name="NoRoute"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3.1"></a><h3>10.3.1.&nbsp;
No Route</h3>

<p>If a Forwarder receives an Interest for which it has no route, or for which the only route is
            back towards the system that sent the Interest, the Forwarder SHOULD generate a "No Route"
            Interest Return message.
</p>
<p>  How a forwarder manages the FIB table
            when it receives a No Route message is implementation dependent.
            In general, receiving a No Route Interest Return should not cause a forwarder to remove
            a route.  The dynamic routing protocol that installed the route should correct the route or
            the administrator who created a static route should correct the configuration.  A forwarder could
            suppress using that next hop for some period of time.
</p>
<a name="HopLimit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3.2"></a><h3>10.3.2.&nbsp;
HopLimit Exceeded</h3>

<p>A Forwarder MAY choose to send HopLimit Exceeded messages when it receives an Interest that must
            be forwarded off system and the HopLimit is 0.
</p>
<a name="MTU"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3.3"></a><h3>10.3.3.&nbsp;
Interest MTU Too Large</h3>

<p>If a Forwarder receives an Interest whose MTU exceeds the prescribed minimum, it MAY send
            an "Interest MTU Too Large" message, or it may silently discard the Interest.
</p>
<p>If a Forwarder receives an "Interest MTU Too Large" is SHOULD NOT try alternate paths.
            It SHOULD propagate the Interest Return to its previous hops.
</p>
<a name="NoResources"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3.4"></a><h3>10.3.4.&nbsp;
No Resources</h3>

<p>If a Forwarder receives an Interest and it cannot process the Interest due to lack of resources,
            it MAY send an InterestReturn.  A lack of resources could be the PIT table is too large, or some other
            capacity limit.
</p>
<a name="PathError"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3.5"></a><h3>10.3.5.&nbsp;
Path Error</h3>

<p>If a forwarder detects an error forwarding an Interest, such as over a reliable link, it MAY send
            a Path Error Interest Return indicating that it was not able to send or repair a forwarding error.
</p>
<a name="Prohibited"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3.6"></a><h3>10.3.6.&nbsp;
Prohibited</h3>

<p>A forwarder may have administrative policies, such as access control lists, that prohibit receiving or
            forwarding an Interest.  If a forwarder discards an Interest due to a policy, it MAY send a Prohibited
            InterestReturn to the previous hop. For example, if there is an ACL that says /parc/private can only come from
            interface e0, but the Forwarder receives one from e1, the Forwarder must have a way to return the Interest with an explanation.
</p>
<a name="Congestion"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3.7"></a><h3>10.3.7.&nbsp;
Congestion</h3>

<p>If a forwarder discards an Interest due to congestion, it MAY send a Congestion InterestReturn to
            the previous hop.
</p>
<a name="UnsupportedHashAlgorithm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3.8"></a><h3>10.3.8.&nbsp;
Unsupported Content Object Hash Algorithm</h3>

<p>If a Content Object Hash Restriction specifies a hash algorithm the forwarder cannot verify,
            the Interest should not be accepted and the forwarder MAY send an InterestReturn to the previous hop.
</p>
<a name="MalformedInterest"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3.9"></a><h3>10.3.9.&nbsp;
Malformed Interest</h3>

<p>If a forwarder detects a structural or syntactical error in an Interest, it SHOULD drop
            the interest and MAY send an InterestReturn to the previous hop.  This does not imply that any
            router must validate the entire structure of an Interest.
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Acknowledgements</h3>

<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
IANA Considerations</h3>

<p>This memo includes no request to IANA. 
</p>
<p>TO_INTERESTLIFETIME = 2 seconds.
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Security Considerations</h3>

<p>The Interest Return message has no authenticator from the previous hop.  Therefore, the payload of the Interest Return
        should only be used locally to match an Interest.  A node should never forward that Interest payload as an Interest.
        It should also verify that it sent the Interest in the Interest Return to that node and not allow anyone to negate
        Interest messages.
</p>
<p>If two peers require authenticated messaging, they must use an external mechanism such as MACSEC.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>14.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="http://www.rfc-editor.org/info/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, DOI&nbsp;10.17487/RFC2119, March&nbsp;1997.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>14.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CCN">[CCN]</a></td>
<td class="author-text">PARC, Inc., &ldquo;<a href="http://www.CCNx.org">CCNx Open Source</a>,&rdquo; 2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="CCNMessages">[CCNMessages]</a></td>
<td class="author-text">Mosko, M. and I. Solis, &ldquo;<a href="http://tools.ietf.org/html/draft-irtf-icnrg-ccnxmessages-01">CCNx Messages in TLV Format (Internet draft)</a>,&rdquo; 2016.</td></tr>
<tr><td class="author-text" valign="top"><a name="CCNxURI">[CCNxURI]</a></td>
<td class="author-text">Mosko, M. and C. Wood, &ldquo;<a href="http://tools.ietf.org/html/draft-mosko-icnrg-ccnxuri-03">The CCNx URI Scheme (Internet draft)</a>,&rdquo; 2016.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3552">[RFC3552]</a></td>
<td class="author-text">Rescorla, E. and B. Korver, &ldquo;<a href="http://www.rfc-editor.org/info/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>,&rdquo; BCP&nbsp;72, RFC&nbsp;3552, DOI&nbsp;10.17487/RFC3552, July&nbsp;2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3986">[RFC3986]</a></td>
<td class="author-text">Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;<a href="http://www.rfc-editor.org/info/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>,&rdquo; STD&nbsp;66, RFC&nbsp;3986, DOI&nbsp;10.17487/RFC3986, January&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5234">[RFC5234]</a></td>
<td class="author-text">Crocker, D., Ed. and P. Overell, &ldquo;<a href="http://www.rfc-editor.org/info/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>,&rdquo; STD&nbsp;68, RFC&nbsp;5234, DOI&nbsp;10.17487/RFC5234, January&nbsp;2008.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Marc Mosko</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">PARC, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Palo Alto, California  94304</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+01 650-812-4405</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:marc.mosko@parc.com">marc.mosko@parc.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ignacio Solis</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">LinkedIn</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mountain View, California  94043</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:nsolis@linkedin.com">nsolis@linkedin.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Christopher Wood</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">PARC, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Palo Alto, California  94304</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:christopher.wood@parc.com">christopher.wood@parc.com</a></td></tr>
</table>
</body></html>
