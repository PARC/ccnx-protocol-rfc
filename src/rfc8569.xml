<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC8174 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">
  <!ENTITY RFC3552 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
  <!ENTITY RFC3986 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml">
  <!ENTITY RFC5226 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
  <!ENTITY RFC5234 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml">
  ]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc private="" ?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>


<!-- [rfced] Please ensure that the guidelines listed in Section 2.1 of RFC
5743 have been adhered to in this document.  
-->

<rfc number="8569" category="exp" submissionType="IRTF" consensus="yes"  ipr="trust200902">
  <front>
    <title abbrev="CCNx Semantics">Content Centric Networking (CCNx) Semantics</title>
    <author fullname="Marc Mosko" initials="M.E." surname="Mosko">
      <organization>PARC, Inc.</organization>
      <address>
        <postal>
          <street/>
          <city>Palo Alto</city>
          <region>California</region>
          <code>94304</code>
          <country>United States of America</country>
        </postal>
        <phone>+01 650-812-4405</phone>
        <email>marc.mosko@parc.com</email>
      </address>
    </author>
    <author fullname="Ignacio Solis" initials="I." surname="Solis">
      <organization>LinkedIn</organization>
      <address>
       <postal>
          <street></street>
         <city>Mountain View</city>
         <region>California</region>
         <code>94043</code>
         <country>United States of America</country>
       </postal>       
       <email>nsolis@linkedin.com</email>
     </address>
    </author>
    <author fullname="Christopher A. Wood" initials="C.A." surname="Wood">
      <organization>University of California Irvine</organization>
      <address>
       <postal>
         <street/>
         <city>Irvine</city>
         <region>California</region>
         <code>92697</code>
         <country>United States of America</country>
       </postal>
       <phone>+01 315-806-5939</phone>
       <email>woodc1@uci.edu</email>
     </address>
    </author>

    <date month="March" year="2019"/>

    <!-- [rfced] With regard to the use of CCNx:
	 
a) Past RFCs have expanded the abbreviation "CCN", but not "CCNx".
What does the "x" stand for?  Is this the project name instead of a
true abbreviation?
	 
b) This document uses "Content Centric Networking" while the majority
of references and scholarly articles appear to use "Content-Centric
Networks/Networking" (note the hyphen).  We will update to the
hyphenated form unless we hear objection.
--> 

    <area>General</area>
    <workgroup>Information-Centric Networking</workgroup>
    <keyword>Content Centric Networking</keyword>
    <abstract>
      <t>This document describes the core concepts of the Content
      Centric Networking (CCNx) architecture and presents a network
      protocol based on two messages: Interests and Content Objects.
      It specifies the set of mandatory and optional fields within
      those messages and describes their behavior and
      interpretation. This architecture and protocol specification is
      independent of a specific wire encoding.</t>

<!--[rfced] In the Abstract, we see the use of "specific wire
encoding" whereas the Introduction uses "specific wire
format encoding".  Should these be made uniform?  -->

      
        
      <t>The protocol also uses a control message called an
      InterestReturn, whereby one system can return an Interest
      message to the previous hop due to an error condition.  This
      indicates to the previous hop that the current system will not
      respond to the Interest.</t>
        
      <t>This document is a product of the Information-Centric Networking 
         Research Group (ICNRG).</t>
    </abstract>
  </front>
  <middle>
    <section title="Introduction">
      <t>This document describes the principles of the CCNx
      architecture. It describes a network protocol that uses a
      hierarchical name to forward requests and to match responses to
      requests.  It does not use endpoint addresses, such as Internet
      Protocol.  Restrictions in a request can limit the response by
      the public key of the response's signer or the cryptographic
      hash of the response.  Every CCNx forwarder along the path does
      the name matching and restriction checking.  The CCNx protocol
      fits within the broader framework of Information-Centric
      Networking (ICN) protocols <xref target="RFC7927"/>.  This
      document concerns the semantics of the protocol and is not
      dependent on a specific wire-format encoding.  The <xref
      target="ccn-messages">CCNx Messages</xref> document describes a
      type-length-value (TLV) wire-protocol encoding.  This section
      introduces the main concepts of CCNx, which are further
      elaborated in the remainder of the document.
      </t>
      
      <t>The CCNx protocol derives from the early ICN work by <xref
      target="nnc">Jacobson, et al.</xref>.  Jacobson's version of
      CCNx is known as the 0.x version ("CCNx 0.x"), and the present
      work is known as the 1.0 version ("CCNx 1.0").  There are two
      active implementations of CCNx 1.0.  The most complete
      implementation is <xref target="cicn">Community ICN
      (CICN)</xref>, a Linux Foundation project hosted at fd.io.
      Another active implementation is <xref
      target="ccn-lite">CCN-lite</xref>, with support for Internet of
      Things (IoT) systems and the RIOT operating system.  CCNx 0.x
      formed the basis of the <xref target="ndn">Named Data Networking
      (NDN)</xref> university project.
      </t>
      
      <t>
      The current CCNx 1.0 specification diverges from CCNx 0.x in a
      few significant areas.  The most pronounced behavioral
      difference between CCNx 0.x and CCNx 1.0 is that CCNx 1.0 has a
      simpler response processing behavior.  In both versions, a
      forwarder uses a hierarchical longest prefix match of a request
      name against the forwarding information base (FIB) to send the
      request through the network to a system that can issue a
      response.  A forwarder must then match a response's name to a
      request's name to determine the reverse path and deliver the
      response to the requester.  In CCNx 0.x, the Interest name may
      be a hierarchical prefix of the response name, which allows a
      form of Layer 3 (L3) content discovery.  In CCNx 1.0, a
      response's name must exactly equal a request's name.  Content
      discovery is performed by a higher-layer protocol.
      </t>

      <t>The selector protocol <xref target="selectors">"CCNx Selectors"</xref> is an example
      of using a higher-layer protocol on top of the CCNx 1.0 L3 to
      perform content discovery.  The selector protocol uses a method
      similar to the original CCNx 0.x techniques without requiring
      partial name matching of a response to a request in the
      forwarder.</t>
      
      <t>This document represents the consensus of the
      Information-Centric Networking Research Group (ICNRG).  It is
      the first ICN protocol from the RG, created from the early CCNx
      protocol <xref target="nnc"/> with significant revision and
      input from the ICN community and RG members.  This document has
      received critical reading by several members of the ICN
      community and the RG.  The authors and RG chairs approve of the
      contents.  This document is sponsored under the IRTF, is not
      issued by the IETF and is not an IETF standard.  This is an
      experimental protocol and may not be suitable for any specific
      application. The specification may change in the future.
		</t>

      <section title="Requirements Language">
        <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref
    target="RFC8174"/> when, and only when, they appear in all
    capitals, as shown here.
        </t>

</section>
      <section title="Architecture">
      <t>We describe the architecture of the network in which CCNx
      operates and introduce certain terminology from <xref
      target="terminology"/>.  The detailed behavior of each component
      and message grammar is in <xref target="protocol"/>.</t>
      
      <t>A producer (also called a "publisher") is an endpoint that
      encapsulates content in Content Objects for transport in the
      CCNx network.  A producer has a public/private keypair and signs
      (directly or indirectly) the Content Objects.  Usually, the
      producer's keyid (hash of the public key) is well known or may
      be derived from the producer's namespace via standard means.</t>
      
<!-- [rfced] This document expands FIB repeatedly throughout.  We
suggest expanding on first use and then using the abbreviation
only as recommended at
https://www.rfc-editor.org/styleguide/part2/.
-->
      <t>A producer operates within one or more namespaces.  A
      namespace is a name prefix that is represented in the forwarding
      information base (FIB).  This allows a request to reach the
      producer and fetch a response (if one exists).</t>
      
      <t>The forwarding information base (FIB) is a table that tells a
      forwarder where to send a request.  It may point to a local
      application, a local cache or Content Store, or to a remote
      system.  If there is no matching entry in the FIB, a forwarder
      cannot process a request.  The detailed rules on name matching
      to the FIB are given in <xref target="interest_pipe"/>.  An
      endpoint has a FIB, though it may be a simple default route.  An
      intermediate system (i.e., a router) typically has a much larger
      FIB.  A core CCNx forwarder, for example, would know all the
      global routes.
      </t>
      
<!-- [rfced] We are having trouble understanding the use of "build on top of
CCNx" in the context here. How may we update for clarity?

Original:
   It is beyond the scope of this document to describe how a consumer
   learns of a name or publisher keyid - - higher layer protocols
   build on top of CCNx handle those tasks, such as search engines or
   lookup services or well known names.

Perhaps:
   It is beyond the scope of this document to describe how a consumer
   learns of a name or publisher keyid; higher-layer protocols built
   on top of CCNx handle those tasks, such as search engines, lookup
   services, or well-known names.

Or perhaps:
   It is beyond the scope of this document to describe how a consumer
   learns of a name or publisher keyid; higher-layer protocols build
   on top of CCNx and handle those tasks, such as search engines,
   lookup services, or well-known names.
-->
      <t>A consumer is an endpoint that requests a name.  It is beyond
      the scope of this document to describe how a consumer learns of
      a name or publisher keyid; higher-layer protocols build on top
      of CCNx handle those tasks, such as search engines or lookup
      services or well-known names.  The consumer constructs a
      request, called an Interest, and forwards it via the endpoint's
      FIB.  The consumer should get back either a response (called a
      Content Object) that matches the Interest or a control message
      (called an InterestReturn) that indicates the network cannot
      handle the request.</t>
      
      <t>There are three ways to detect errors in Interest handling.
      An InterestReturn is a network control message that indicates a
      low-level error like "no route" or "out of resources".  If an
      Interest arrives at a producer, but the producer does not have
      the requested content, the producer should send an
      application-specific error message (e.g., a "not found"
      message).  Finally, a consumer may not receive anything; in
      which case, it should timeout and, depending on the application,
      retry the request or return an error to the application.</t>
      </section>
      
      <section title="Protocol Overview">
      	<t>The goal of CCNx is to name content and retrieve the
      	content from the network without binding it to a specific
      	network endpoint.  A routing system (specified separately)
      	populates the forwarding information base (FIB) tables at each
      	CCNx router with hierarchical name prefixes that point towards
      	the content producers under that prefix.  A request finds
      	matching content along those paths, in which case a response
      	carries the data, or, if no match is found, a control message
      	indicates the failure.  A request may further refine
      	acceptable responses with a restriction on the response's
      	signer and the cryptographic hash of the response.  The
      	details of these restrictions are described below.
      	</t>
      	
      	<t>The CCNx name is a hierarchical series of path segments.
      	Each path segment has a type and zero or more bytes.  Matching
      	two names is done as a binary comparison of the type and
      	value, and is done segment by segment.  The human-readable
      	form is defined under a URI scheme <xref
      	target="ccnx-uri">"ccnx:"</xref>, though the canonical
      	encoding of a name is a series of pairs (type, octet string).
      	There is no requirement that any path segment be human
      	readable or UTF-8.  The first few segments in a name will be
      	matched against the FIB, and a routing protocol may put its
      	own restrictions on the routable name components (e.g., a
      	maximum length or character-encoding rules).  In principle,
      	path segments and names have unbounded length, though in
      	practice they are limited by the wire-format encoding and
      	practical considerations imposed by a routing protocol.  Note
      	that in CCNx, path segments use binary comparison, whereas in a
      	URI, the authority uses a case-insensitive hostname (due to
      	DNS).</t>
      	
      	<t>The CCNx name, as used by the forwarder, is purposefully
      	left as a general octet-encoded type and value without any
      	requirements on human readability and character encoding.  The
      	reason for this is that we are concerned with how a forwarder
      	processes names.  We expect that applications, routing
      	protocols, or other higher layers will apply their own
      	conventions and restrictions on the allowed path-segment types
      	and path-segment values.</t>
      
        <t>CCNx is a request and response protocol that fetches chunks
        of data using a name. The integrity of each chunk may be
        directly asserted through a digital signature or Message
        Authentication Code (MAC), or, alternatively, indirectly via
        hash chains. Chunks may also carry weaker Message Integrity
        Checks (MICs) or no integrity protection mechanism at all.
        Because provenance information is carried with each chunk (or
        larger indirectly protected block), we no longer need to rely
        on host identities, such as those derived from TLS
        certificates, to ascertain the chunk legitimacy.

<!--[rfced] Should this semi-colon be made a colon?  That is does the
second portion illustrate or amplify the first part?  However, if
they are simply related thoughts, then we will leave as is.

Original:
Data integrity is
   therefore a core feature of CCNx; it does not rely on the data
   transmission channel.
   
Perhaps:
Therefore, data integrity is
   a core feature of CCNx: it does not rely on the data
   transmission channel. 
-->
	Therefore, data
        integrity is a core feature of CCNx; it does not
        rely on the data transmission channel. There are several
        options for data confidentiality, discussed later.
        </t>
        <t>This document only defines the general properties of CCNx
        names.  In some isolated environments, CCNx users may be able
        to use any name they choose and either inject that name (or
        prefix) into a routing protocol or use other information
        foraging techniques.  In the Internet environment, there will
        be policies around the formats of names and assignments of
        names to publishers, though those are not specified here.
        </t>
        <t>The key concept of CCNx is that a subjective name is
        cryptographically bound to a fixed payload. These
        publisher-generated bindings can therefore be
        cryptographically verified.  A named payload is thus the tuple
        {{Name, ExtraFields, Payload, ValidationAlgorithm},
        ValidationPayload}, where all fields in the inner tuple are
        covered by the validation payload (e.g., signature).
        Consumers of this data can check the binding integrity by
        re-computing the same cryptographic hash and verifying the
        digital signature in ValidationPayload.
           </t>

<!-- [rfced] In the following sentence, should RSA be expanded to
"Routing and Spectrum Assignment", or is the more common term
"Rivest, Shamir and Adleman" intended? Also, please verify that
CRC expands to "Cyclic Redundancy Check".

Original: 
   In addition to digital signatures (e.g.  RSA), CCNx also supports
   message authentication codes (e.g.  HMAC) and message integrity codes
   (e.g.  SHA-256 or CRC).
-->
       <t>
           In addition to digital signatures (e.g., RSA), CCNx also
           supports message authentication codes (e.g., Hashed Message
           Authentication Code (HMAC)) and message integrity codes
           (e.g., SHA-256 or Cyclic Redundancy Checks (CRC)).  To
           maintain the cryptographic binding, there should be at
           least one object with a signature or authentication code,
           but not all objects require it.  For example, a first
           object with a signature could refer to other objects via a
           hash chain, a Merkle tree, or a signed manifest.  The later
           objects may not have any validation and rely purely on the
           references.  The use of an integrity code (e.g., CRC) is
           intended for detecting accidental corruption in an
           Interest.
       </t>
<!-- [rfced] Please verify that the use of "Content ObjectHash
restriction" is used as intended in the following sentence (as
opposed to Content Object Hash restriction).

Original: 
   The second is the Content ObjectHash restriction, which limits the response
   to one where the cryptographic hash of the entire named payload is equal to
   the restriction. 
-->

<!-- [rfced] This document uses "Content-Object hash restriction",
"Content-Object Hash Restriction", "Content Object Hash
Restriction", "Hash restriction", and "Content ObjectHashRestr"
throughout. Is there a preferred format when not intending
"ContentObjectHashRestr"?
-->

        <t>CCNx specifies a network protocol around Interests (request
        messages) and Content Objects (response messages) to move
        named payloads.  An Interest includes the Name, which
        identifies the desired response, and optional matching
        restrictions.  Restrictions limit the possible matching
        Content Objects. Two restrictions exist: KeyIdRestr and
        ContentObjectHashRestr. The first restriction on the KeyId
        limits responses to those signed with a ValidationAlgorithm
        KeyId field equal to the restriction.  The second is the
        Content ObjectHash restriction, which limits the response to
        one where the cryptographic hash of the entire named payload
        is equal to the restriction.
        </t>
        <t>The hierarchy of a CCNx Name is used for routing via the
        longest matching prefix in a Forwarder.  The longest matching
        prefix is computed name segment by name segment in the
        hierarchical path name, where each name segment must be
        exactly equal to match.  There is no requirement that the
        prefix be globally routable.  Within a deployment, any local
        routing may be used, even one that only uses a single flat
        (non-hierarchical) name segment.
        </t>
        <t>Another concept of CCNx is that there should be flow
        balance between Interest messages and Content-Object messages.
        At the network level, an Interest traveling along a single
        path should elicit no more than one Content-Object response.
        If some node sends the Interest along more than one path, that
        node should consolidate the responses such that only one
        Content Object flows back towards the requester.  If an
        Interest is sent broadcast or multicast on a multiple-access
        media, the sender should be prepared for multiple responses
        unless some other media-dependent mechanism like gossip
        suppression or leader election is used.
        </t>
        <t>
          As an Interest travels the forward path following the
          Forwarding Information Base (FIB), it establishes state at
          each forwarder such that a Content-Object response can trace
          its way back to the original requester(s) without the
          requester needing to include a routable return address.  We
          use the notional Pending Interest Table (PIT) as a method to
          store state that facilitates the return of a Content Object.
        </t>
        <t>The notional PIT table stores the last hop of an Interest
        plus its Name and optional restrictions.  This is the data
        required to match a Content Object to an Interest (see <xref
        target="matching"/>).  When a Content Object arrives, it must
        be matched against the PIT to determine which entries it
        satisfies.  For each such entry, at most one copy of the
        Content Object is sent to each listed last hop in the PIT
        entries.
        </t>

<!--[rfced] Should "the specification" be updated to "this
specification" for clarity?

Original:
An actual PIT table is not mandated by the specification.

Perhaps:
An actual PIT table is not mandated by this specification.
-->
        <t>An actual PIT table is not mandated by the specification.
        An implementation may use any technique that gives the same
        external behavior.  There are, for example, research papers
        that use techniques like label switching in some parts of the
        network to reduce the per-node state incurred by the PIT table
        <xref target="dart"/>.  Some implementations store the PIT
        state in the FIB, so there is not a second table.</t>
        
<!-- [rfced] This document uses the format "the tuple {X, Y, Z}" as
well as "the {X, Y, Z} tuple". Is there a preferred format that
should be used consistently?

Original:
    A named payload is thus the tuple {{Name, ExtraFields, Payload,
   ValidationAlgorithm}, ValidationPayload}...
   ...
   If multiple Interests with the same {Name, KeyIdRestr,
   ContentObjectHashRestr} tuple arrive at a node...
-->
        <t>If multiple Interests with the same {Name, KeyIdRestr,
        ContentObjectHashRestr} tuple arrive at a node before a
        Content Object matching the first Interest comes back, they
        are grouped in the same PIT entry and their last hops are
        aggregated (see <xref target="aggregation"/>).  Thus, one
        Content Object might satisfy multiple pending Interests in a
        PIT.
        </t>
        <t>In CCNx, higher-layer protocols are often called
        "name-based protocols" because they operate on the CCNx Name.
        For example, a versioning protocol might append additional
        name segments to convey state about the version of payload.  A
        content discovery protocol might append certain
        protocol-specific name segments to a prefix to discover
        content under that prefix.  Many such protocols may exist and
        apply their own rules to Names. They may be layered with each
        protocol encapsulating (to the left) a higher layer's Name
        prefix.
        </t>
        <t>This document also describes a control message called an
        InterestReturn.  A network element may return an Interest
        message to a previous hop if there is an error processing the
        Interest. The returned Interest may be further processed at
        the previous hop or returned towards the Interest origin.
        When a node returns an Interest, it indicates that the
        previous hop should not expect a response from that node for
        the Interest, i.e., there is no PIT entry left at the
        returning node for a Content Object to follow.
        </t>
        <t>There are multiple ways to describe larger objects in CCNx.
        Aggregating L3 Content Objects into larger objects is beyond
        the scope of this document.  One proposed method, File-Like
        ICN Collection <xref target="flic">(FLIC)</xref>, uses a
        manifest to enumerate the pieces of a larger object.
        Manifests are, themselves, Content Objects.  Another option is
        to use a convention in the Content-Object name, as in the
        <xref target="chunking">CCNx Chunking</xref> protocol where a
        large object is broken into small chunks and each chunk
        receives a special name component indicating its serial order.
        </t>
        <t>At the semantic level, described in this document, we do
        not address fragmentation.  One experimental fragmentation
        protocol, <xref target="befrags">BeginEnd Fragments</xref>,
        uses a multipoint PPP-style technique for use over L2
        interfaces with the specification for <xref
        target="ccn-messages">CCNx Messages</xref> in TLV wire format.
        </t>
        <t>With these concepts, the remainder of the document
        specifies the behavior of a forwarder in processing Interest,
        Content Object, and InterestReturn messages.
        </t>
      </section>
    </section>
    <section anchor="protocol" title="Protocol">
      <t>CCNx is a request and response protocol. A request is called
      an "Interest" and a response is called a "Content Object".  CCNx
      also uses a 1-hop control message called InterestReturn.  These
      are, as a group, called CCNx Messages.</t>

      <section anchor="grammar" title="Message Grammar">
        <t>

<!--[rfced] We note that what appears in Figure 1 is not
actually parsable ABNF.  Please review whether the
introductory text (copied below) should be updated or
if the contents of the figure should be updated.

Original:
The CCNx message ABNF [RFC5234] grammar is shown in Figure 1

-->
	  
          The CCNx Message <xref target="RFC5234">ABNF</xref> grammar
          is shown in <xref target="abnfgrammar"/>.  The grammar does
          not include any encoding delimiters, such as TLVs.  Specific
          wire encodings are given in a separate document.  If a
          Validation section exists, the Validation Algorithm covers
          from the Body (BodyName or BodyOptName) through the end of
          the ValidationAlg section.  The InterestLifetime, CacheTime,
          and Return Code fields exist outside of the validation
          envelope and may be modified.
        </t>

        <t>The various fields, in alphabetical order, are defined as:
          <list style="hanging">
            <t hangText="AbsTime:">Absolute times are conveyed as the 64-bit UTC time in milliseconds
              since the epoch (standard POSIX time).
            </t>
            <t hangText="CacheTime:"> The absolute time after which the publisher
            believes there is low value in caching the Content Object.
            This is a recommendation to caches (see <xref
            target="cachecontrol"/>).
            </t>
            <t hangText="ConObjField:">These are optional fields that may appear
            in a Content Object.
            </t>
            <t hangText="ConObjHash:">The value of the Content-Object Hash, which
            is the SHA256-32 over the message from the beginning of
            the body to the end of the message.  Note that this
            coverage area is different from the ValidationAlg.  This
            value SHOULD NOT be trusted across domains (see <xref
            target="ConObjHash"/>).
            </t>
	                <t hangText="ContentObjectHashRestr:">The Content-Object Hash
            Restriction.  A Content Object must hash to the same value
            as the restriction using the same HashType.  The
            ContentObjectHashRestr MUST use SHA256-32.
            </t>
            <t hangText="ExpiryTime:">An absolute time after which the Content
            Object should be considered expired (see <xref
            target="cachecontrol"/>).
            </t>
            <t hangText="Hash:">Hash values carried in a Message carry a HashType
            to identify the algorithm used to generate the hash
            followed by the hash value.  This form is to allow hash
            agility.  Some fields may mandate a specific HashType.
            </t>
            <t hangText="HopLimit:">Interest messages may loop if there are loops
            in the forwarding plane.  To eventually terminate loops,
            each Interest carries a HopLimit that is decremented after
            each hop and no longer forwarded when it reaches zero.
            See <xref target="forwarder"/>.
            </t>
            <t hangText="InterestField:">These are optional fields that may
            appear in an Interest message.
            </t>
	    <t hangText="KeyId:">An identifier for the key used in the
            ValidationAlg.  For public key systems, this should be the
            SHA-256 hash of the public key.  For symmetric key
            systems, it should be an identifier agreed upon by the
            parties.
            </t>
            <t hangText="KeyIdRestr:">The KeyId Restriction.  A Content Object
            must have a KeyId with the same value as the restriction.
            </t>
         
            <t hangText="KeyLink:">A Link (see <xref target="link"/>) that names
            how to retrieve the key used to verify the
            ValidationPayload.  A message SHOULD NOT have both a
            KeyLink and a PublicKey.
            </t>
            <t hangText="Lifetime:">The approximate time during which a requester
            is willing to wait for a response, usually measured in
            seconds.  It is not strongly related to the network
            round-trip time, though it must necessarily be larger.
            </t>
            <t hangText="Name:">A name is made up of a non-empty first segment
            followed by zero or more additional segments, which may be
            of 0 length.  Path segments are opaque octet strings and
            are thus case sensitive if encoding UTF-8.  An Interest
            MUST have a Name.  A Content Object MAY have a Name (see
            <xref target="matching"/>).  The segments of a name are
            said to be complete if its segments uniquely identify a
            single Content Object. A name is exact if its segments are
            complete. An Interest carrying a full name is one that
            specifies an exact name and the ContentObjectHashRestr of
            the corresponding Content Object.
            </t>
            <t hangText="Payload:">The message's data, as defined by PayloadType.
            </t>
            <t hangText="PayloadType:">The format of the Payload.  If missing,
            assume DataType.  DataType means the payload is opaque
            application bytes.  KeyType means the payload is a
            DER-encoded public key.  LinkType means it is one or more
            Links (see <xref target="link"/>).
            </t>
            <t hangText="PublicKey:">Some applications may wish to embed the
            public key used to verify the signature within the message
            itself.  The PublickKey is DER encoded.  A message SHOULD
            NOT have both a KeyLink and a PublicKey.
            </t>
            <t hangText="RelTime:">A relative time, measured in milliseconds.
            </t>
            <t hangText="ReturnCode:">States the reason an Interest message is
            being returned to the previous hop (see <xref
            target="TypeDefinitions"/>).
            </t>
            <t hangText="SigTime:">The absolute time (UTC milliseconds) when the
            signature was generated.
            </t>
            <t hangText="Vendor:">Vendor-specific opaque data.  The Vendor data
            includes the <xref target="eprise-numbers">IANA Private
            Enterprise Numbers</xref>, followed by vendor-specific
            information.  CCNx allows vendor-specific data in most
            locations of the grammar.
            </t>
          </list>
        </t>


       <figure anchor="abnfgrammar" title="CCNx Message ABNF">
        <artwork align="left"><![CDATA[
Message       = Interest / ContentObject / InterestReturn
Interest      = IntHdr BodyName [Validation]
IntHdr        = HopLimit [Lifetime] *Vendor
ContentObject = ConObjHdr BodyOptName [Validation]
ConObjHdr     = [CacheTime / ConObjHash] *Vendor
InterestReturn= ReturnCode Interest
BodyName      = Name Common
BodyOptName   = [Name] Common
Common        = *Field [Payload]
Validation    = ValidationAlg ValidatonPayload

Name          = FirstSegment *Segment
FirstSegment  = 1*OCTET / Vendor
Segment       = 0*OCTET / Vendor

ValidationAlg = (RSA-SHA256 / HMAC-SHA256 / CRC32C) *Vendor
ValidatonPayload = 1*OCTET
RSA-SHA256    = KeyId [SigTime] [KeyLink] [PublicKey] [Cert]
HMAC-SHA256   = KeyId [SigTime] [KeyLink]
CRC32C        = [SigTime]

AbsTime       = 8OCTET ; 64-bit UTC msec since epoch
CacheTime     = AbsTime
ConObjField   = ExpiryTime / PayloadType
ConObjHash    = Hash
ExpiryTime    = AbsTime
Field         = InterestField / ConObjField / Vendor
Hash          = HashType 1*OCTET
HashType      = 2OCTET ; IANA CCNx Hash Function Types
HopLimit      = OCTET
InterestField = KeyIdRestr / ContentObjectHashRestr
KeyId         = 1*OCTET
KeyIdRestr    = 1*OCTET
KeyLink       = Link
Lifetime      = RelTime
Link          = Name [KeyIdRestr] [ContentObjectHashRestr]
ContentObjectHashRestr  = Hash
Payload       = *OCTET
PayloadType   = OCTET ; IANA CCNx Payload Types
PublicKey     = *OCTET ; DER-encoded public key
Cert          = *OCTET ; DER-encoded X.509 Certificate
RelTime       = 1*OCTET ; msec
ReturnCode    = OCTET ; see Section 10.2
SigTime       = AbsTime
Vendor        = PEN 0*OCTET
PEN           = 1*OCTET ; IANA Private Enterprise Number
]]></artwork>
      </figure>

<!-- [rfced] Should Figure 1 in Section 2.1 have a title added to be
consistent with tables in other sections?

Original:

   PublicKey     := ; DER-encoded public key
   RelTime       := 1* OCTET ; msec
   ReturnCode    := ; see Section 10.2
   SigTime       := AbsTime
   Vendor        := PEN 0* OCTET
   PEN           := ; IANA Private Enterprise Number

                                 Figure 1

Perhaps:

   PublicKey     := ; DER-encoded public key
   RelTime       := 1* OCTET ; msec
   ReturnCode    := ; see Section 10.2
   SigTime       := AbsTime
   Vendor        := PEN 0* OCTET
   PEN           := ; IANA Private Enterprise Number

                                 Figure 1: CCNx Message ABNF Grammar
-->
      </section>

      <section anchor="consumer" title="Consumer Behavior">
        <t>
        To request a piece of content for a given {Name, [KeyIdRest],
        [ContentObjectHashRestr]} tuple, a consumer creates an
        Interest message with those values.  It MAY add a validation
        section, typically only a CRC32C.  A consumer MAY put a
        Payload field in an Interest to send additional data to the
        producer beyond what is in the Name.  The Name is used for
        routing and may be remembered at each hop in the notional PIT
        table to facilitate returning a Content Object; Storing large
        amounts of state in the Name could lead to high memory
        requirements.  Because the Payload is not considered when
        forwarding an Interest or matching a Content Object to an
        Interest, a consumer SHOULD put an Interest Payload ID (see
        <xref target="ipid"/>) as part of the name to allow a
        forwarder to match Interests to Content Objects and avoid
        aggregating Interests with different payloads. Similarly, if a
        consumer uses a MAC or a signature, it SHOULD also include a
        unique segment as part of the name to prevent the Interest
        from being aggregated with other Interests or satisfied by a
        Content Object that has no relation to the validation.
        </t>

        <t>The consumer SHOULD specify an InterestLifetime, which is
        the length of time the consumer is willing to wait for a
        response.  The InterestLifetime is an application-scale time,
        not a network round-trip time (see <xref
        target="aggregation"/>).  If not present, the InterestLifetime
        will use a default value (2 seconds).
        </t>
        <t>The consumer SHOULD set the Interest HopLimit to a
        reasonable value or use the default 255.  If the consumer
        knows the distances to the producer via routing, it SHOULD use
        that value.
        </t>
        <t>A consumer hands off the Interest to its first forwarder,
        which will then forward the Interest over the network to a
        publisher (or replica) that may satisfy it based on the name
        (see <xref target="forwarder"/>).
        </t>
        <t>Interest messages are unreliable.  A consumer SHOULD run a
        transport protocol that will retry the Interest if it goes
        unanswered, up to the InterestLifetime.  No transport protocol
        is specified in this document.
        </t>
        <t>The network MAY send to the consumer an InterestReturn
        message that indicates the network cannot fulfill the
        Interest.  The ReturnCode specifies the reason for the
        failure, such as no route or congestion.  Depending on the
        ReturnCode, the consumer MAY retry the Interest or MAY return
        an error to the requesting application.
        </t>
        <t>If the content was found and returned by the first forwarder, the
        consumer will receive a Content Object.  The consumer SHOULD:


<!--[rfced] Regarding the list in Section 2.2:
	    
a) Please note that the text that introduces the list
does not fit with all of the entries.
That is, it seems like each entry in the list should
complete the sentence "The consumer SHOULD" but several
points even use other modal verbs (e.g., "MAY") or
requirements levels (e.g., "should").  Please consider
updating this list so that entries are parallel and the
introductory text makes sense.

b) Please review the use of the pronoun "it".  Will it be clear to the
reader who/what "it" refers to in each case?
-->

	
          <list style="symbols">
            <t>Ensure the Content Object is properly formatted.
            </t>

<!-- [rfced] This document appears to use both "name" and "Name" throughout as
used as a technical noun. Is there a differentiation between uses or should
they all follow the same capitalization?

Original:
   Note that as per the message grammar, an Interest must have a
   Name with at least one name segment and that name segment must have
   at least 1 octet of value.  A Content Object must have a similar name
   or no name at all.     
 -->
            <t>Verify that the returned Name matches a pending
            request.  If the request also had KeyIdRestr or
            ObjHashRest, it MUST also validate those properties.
            </t>
            <t>If the Content Object is signed, it SHOULD
            cryptographically verify the signature.  If it does not
            have the corresponding key, it SHOULD fetch the key, such
            as from a key resolution service or via the KeyLink.
            </t>
            <t>If the signature has a SigTime, the consumer MAY use
            that in considering if the signature is valid.  For
            example, if the consumer is asking for dynamically
            generated content, it should expect the SigTime not to be
            before the time the Interest was generated.
            </t>
            <t>If the Content Object is signed, it should assert the
            trustworthiness of the signing key to the namespace.  Such
            an assertion is beyond the scope of this document, though
            one may use traditional PKI methods, a trusted key
            resolution service, or methods like <xref
            target="trust"/>.
	    
            </t>
            <t>It MAY cache the Content Object for future use, up to
            the ExpiryTime if present.
            </t>
            <t>A consumer MAY accept a Content Object off the wire
            that is expired.  It may happen that a packet expires
            while in flight, and there is no requirement that
            forwarders drop expired packets in flight.  The only
            requirement is that Content Stores, caches, or producers
            MUST NOT respond with an expired Content Object.
            </t>
          </list>
        </t>
      </section>

      <section anchor="publisher" title="Publisher Behavior">
        <t> This document does not specify the method by which names
        populate a Forwarding Information Base (FIB) table at
        forwarders (see <xref target="forwarder"/>).  A publisher is
        either configured with one or more name prefixes under which
        it may create content or it chooses its name prefixes and
        informs the routing layer to advertise those prefixes.
        </t>
        <t>When a publisher receives an Interest, it SHOULD:
          <list style="symbols">
            <t>Verify that the Interest is part of the publishers namespace(s).
            </t>
            <t>If the Interest has a Validation section, verify the
            ValidationPayload.  Usually an Interest will only have a
            CRC32C, unless the publisher application specifically
            accommodates other validations.  The publisher MAY choose
            to drop Interests that carry a Validation section if the
            publisher application does not expect those signatures, as
            this could be a form of computational denial of service.
            If the signature requires a key that the publisher does
            not have, it is NOT RECOMMENDED that the publisher fetch
            the key over the network unless it is part of the
            application's expected behavior.
            </t>
            <t>Retrieve or generate the requested Content Object and
            return it to the Interest's previous hop.  If the
            requested content cannot be returned, the publisher SHOULD
            reply with an InterestReturn or a Content Object with
            application payload that says the content is not
            available; this Content Object should have a short
            ExpiryTime in the future or not be cacheable (i.e., an
            expiry time of 0).
            </t>
          </list>
        </t>
      </section>

      <section anchor="forwarder" title="Forwarder Behavior">
        <t>A forwarder routes Interest messages based on a Forwarding
        Information Base (FIB), returns Content Objects that match
        Interests to the Interest's previous hop, and processes
        InterestReturn control messages.  It may also keep a cache of
        Content Objects in the notional Content-Store table.  This
        document does not specify the internal behavior of a
        forwarder, only these and other external behaviors.
        </t>
        <t>In this document, we will use two processing pipelines: one
        for Interests and one for Content Objects.  Interest
        processing is made up of checking for duplicate Interests in
        the PIT (see <xref target="aggregation"/>), checking for a
        cached Content Object in the Content Store (see <xref
        target="contentstore"/>), and forwarding an Interest via the
        FIB.  Content-Store processing is made up of checking for
        matching Interests in the PIT and forwarding to those previous
        hops.
        </t>
        <section anchor="hoplimit" title="Interest HopLimit">
          <t>Interest looping is not prevented in CCNx. An Interest
          traversing loops is eventually discarded using the hop-limit
          field of the Interest, which is decremented at each hop
          traversed by the Interest.
         </t>

<!-- [rfced] Please verify that only "Content" was intended and not
"Content Object". If "Content" was intended, should both
instances be capitalized?

Original:
   In this case, the Content will be sent back along the loop and eventually
   return to a node that already forwarded the content, so it will likely not
   have a PIT entry anymore.
-->
          <t>
            A loop may also terminate because the Interest is
            aggregated with its previous PIT entry along the loop.  In
            this case, the Content will be sent back along the loop
            and eventually return to a node that already forwarded the
            content, so it will likely not have a PIT entry
            anymore. When the content reaches a node without a PIT
            entry, it will be discarded.  It may be that a new
            Interest or another looped Interest will return to that
            same node, in which case the node will return a cached
            response to make a new PIT entry, as below.
          </t>
          <t>The HopLimit is the last resort method to stop Interest
          loops where a Content Object chases an Interest around a
          loop and where the intermediate nodes, for whatever reason,
          no longer have a PIT entry and do not cache the Content
          Object.
          </t>
          <t>Every Interest MUST carry a HopLimit.  An Interest
          received from a local application MAY have a 0 HopLimit,
          which restricts the Interest to other local sources.
          </t>
          <t>When an Interest is received from another forwarder, the
          HopLimit MUST be positive, otherwise the forwarder will
          discard the Interest.  A forwarder MUST decrement the
          HopLimit of an Interest by at least 1 before it is
          forwarded.
          </t>
          <t>If the decremented HopLimit equals 0, the Interest MUST
          NOT be forwarded to another forwarder; it MAY be sent to a
          local publisher application or serviced from a local Content
          Store.
          </t>
          <t>A RECOMMENDED HopLimit processing pipeline is below:
              <list style="symbols">
                <t>If Interest received from a remote system:
                      <list style="symbols">
                          <t>If received HopLimit is 0, optionally
                          send InterestReturn (HopLimit Exceeded), and
                          discard Interest.</t>
                          <t>Otherwise, decrement the HopLimit by 1.</t>
                      </list>
                </t>
                <t>Process as per Content-Store and Aggregation rules.</t>
                <t>If the Interest will be forwarded:
                    <list style="symbols">
                        <t>If the (potentially decremented) HopLimit
                        is 0, restrict forwarding to the local
                        system.</t>
                        <t>Otherwise, forward as desired to local or
                        remote systems.</t>
                    </list>
                </t>
              </list>
        </t>
        </section>

            <section anchor="aggregation" title="Interest Aggregation">
            <t>Interest aggregation is when a forwarder receives an
            Interest message that could be satisfied by the response
            to another Interest message already forwarded by the node,
            so the forwarder suppresses forwarding the new Interest;
            it only records the additional previous hop so a Content
            Object sent in response to the first Interest will satisfy
            both Interests.
          </t>
            <t>CCNx uses an Interest aggregation rule that assumes the
            InterestLifetime is akin to a subscription time and is not
            a network round-trip time.  Some previous aggregation
            rules assumed the lifetime was a round-trip time, but this
            leads to problems of expiring an Interest before a
            response comes if the RTT is estimated too short or
            interfering with an Automatic Repeat ReQuest (ARQ) scheme
            that wants to retransmit an Interest but a prior Interest
            overestimated the RTT.
          </t>
<!-- [rfced] Please verify that the use of "forwarded" is intended as it
appears in the following sentence and is not meant to be "forwarder" or have a
noun after it.

Original:
   A forwarder MUST still satisfy all pending Interests, so one Content Object
   could satisfy multiple similar interests, even if the forwarded did not
   suppress duplicate Interest messages.
-->
            <t>A forwarder MAY implement an Interest aggregation
            scheme.  If it does not, then it will forward all Interest
            messages.  This does not imply that multiple, possibly
            identical, Content Objects will come back.  A forwarder
            MUST still satisfy all pending Interests, so one Content
            Object could satisfy multiple similar Interests, even if
            the forwarded did not suppress duplicate Interest
            messages.
          </t>
            <t>A RECOMMENDED Interest aggregation scheme is:
            <list style="symbols">
            <t>Two Interests are considered "similar" if they have the
            same Name, KeyIdRestr, and ContentObjectHashRestr.
          </t>
            <t>Let the notional value InterestExpiry (a local value at
            the forwarder) be equal to the receive time plus the
            InterestLifetime (or a platform-dependent default value if
            not present).
          </t>
            <t>An Interest record (PIT entry) is considered invalid if
            its InterestExpiry time is in the past.
          </t>
            <t>The first reception of an Interest MUST be forwarded.
          </t>
            <t>A second or later reception of an Interest similar to a
            valid pending Interest from the same previous hop MUST be
            forwarded.  We consider these a retransmission request.
          </t>
            <t>A second or later reception of an Interest similar to a
            valid pending Interest from a new previous hop MAY be
            aggregated (not forwarded).  If this Interest has a larger
            HopLimit than the pending Interest, it MUST be forwarded.
          </t>
            <t>Aggregating an Interest MUST extend the InterestExpiry
            time of the Interest record.  An implementation MAY keep a
            single InterestExpiry time for all previous hops or MAY
            keep the InterestExpiry time per previous hop.  In the
            first case, the forwarder might send a Content Object down
            a path that is no longer waiting for it, in which case the
            previous hop (next hop of the Content Object) would drop
            it.
          </t>
          </list>
          </t>


        </section>

        <section anchor="contentstore" title="Content-Store Behavior">
          <t>The Content Store is a special cache that is an integral
          part of a CCNx forwarder.  It is an optional component.  It
          serves to repair lost packets and handle flash requests for
          popular content.  It could be pre-populated or use
          opportunistic caching.  Because the Content Store could
          serve to amplify an attack via cache poisoning, there are
          special rules about how a Content Store behaves.
            <list style="numbers">
              <t>A forwarder MAY implement a Content Store.  If it
              does, the Content Store matches a Content Object to an
              Interest via the normal matching rules (see <xref
              target="matching"/>).
              </t>
              <t>If an Interest has a KeyIdRestr, then the Content
              Store MUST NOT reply unless it knows the signature on
              the matching Content Object is correct.  It may do this
              by external knowledge (i.e., in a managed network or
              system with pre-populated caches) or by having the
              public key and cryptographically verifying the
              signature.  A Content Store is NOT REQUIRED to verify
              signatures; if it does not, then it treats these cases
              like a cache miss.
              </t>
              <t>  
                If a Content Store chooses to verify signatures, then
                it MAY do so as follows.  If the public key is
                provided in the Content Object itself (i.e., in the
                PublicKey field) or in the Interest, the Content Store
                MUST verify that the public key's SHA-256 hash is
                equal to the KeyId and that it verifies the signature.
                A Content Store MAY verify the digital signature of a
                Content Object before it is cached, but it is not
                required to do so.  A Content Store SHOULD NOT fetch
                keys over the network.  If it cannot or has not yet
                verified the signature, it should treat the Interest
                as a cache miss.
              </t>
              <t>If an Interest has a ContentObjectHashRestr, then the
              Content Store MUST NOT reply unless it knows the
              matching Content Object has the correct hash.  If it
              cannot verify the hash, then it should treat the
              Interest as a cache miss.
              </t>
              <t>It must obey the cache control directives (see <xref
              target="cachecontrol"/>).
              </t>
            </list>
          </t>
        </section>

        <section anchor="interest_pipe" title="Interest Pipeline">
          <t>
            <list style="numbers">
              <t>Perform the HopLimit check (see <xref
              target="hoplimit"/>).
              </t>
              <t>Determine if the Interest can be aggregated as per
              <xref target="aggregation"/>.  If it can be, aggregate
              and do not forward the Interest.
              </t>
              <t>If forwarding the Interest, check for a hit in the
              Content Store as per <xref target="contentstore"/>.  If
              a matching Content Object is found, return it to the
              Interest's previous hop.  This injects the Content Store
              as per <xref target="object_pipe"/>.
              </t>
              <t>Look up the Interest in the FIB.  Longest Prefix
              Match (LPM) is performed name segment by name segment
              (not byte or bit).  It SHOULD exclude the Interest's
              previous hop.  If a match is found, forward the
              Interest.  If no match is found or the forwarder chooses
              not to forward due to a local condition (e.g.,
              congestion), it SHOULD send an InterestReturn message as
              per <xref target="InterestReturn"/>.</t>
            </list>
          </t>
        </section>

        <section anchor="object_pipe" title="Content-Object Pipeline">
          <t>
            <list style="numbers">
              <t>It is RECOMMENDED that a forwarder that receives a
              Content Object check that the Content Object came from
              an expected previous hop.  An expected previous hop is
              one pointed to by the FIB or one recorded in the PIT as
              having had a matching Interest sent that way.
              </t>
              <t>A Content Object MUST be matched to all pending
              Interests that satisfy the matching rules (see <xref
              target="matching"/>).  Each satisfied pending Interest
              MUST then be removed from the set of pending Interests.
              </t>
              <t>A forwarder SHOULD NOT send more than one copy of the
              received Content Object to the same Interest previous
              hop.  It may happen, for example, that two Interests ask
              for the same Content Object in different ways (e.g., by
              name and by name and KeyId), and that they both come
              from the same previous hop.  It is normal to send the
              same Content Object multiple times on the same
              interface, such as Ethernet, if it is going to different
              previous hops.
              </t>
              <t>A Content Object SHOULD only be put in the Content
              Store if it satisfied an Interest (and passed rule #1
              above).  This is to reduce the chances of cache
              poisoning.
              </t>
            </list>
          </t>
        </section>

      </section>
    </section>

    <section anchor="names" title="Names">
      <t>A CCNx name is a composition of name segments. Each name
      segment carries a label identifying the purpose of the name
      segment, and a value.  For example, some name segments are
      general names and some serve specific purposes such as carrying
      version information or the sequencing of many chunks of a large
      object into smaller, signed Content Objects.</t>
      <t>There are three different types of names in CCNx: prefix,
      exact, and full names.  A prefix name is simply a name that does
      not uniquely identify a single Content Object, but rather a
      namespace or prefix of an existing Content-Object name.  An
      exact name is one that uniquely identifies the name of a Content
      Object.  A full name is one that is exact and is accompanied by
      an explicit or implicit ConObjHash.  The ConObjHash is explicit
      in an Interest and implicit in a Content Object.</t>
      <t>Note that a forwarder does not need to know any semantics
      about a name.  It only needs to be able to match a prefix to
      forward Interests and match an exact or full name to forward
      Content Objects.  It is not sensitive to the name-segment types.
      </t>
<!-- [rfced] This document uses "name segment","Name segment", and
"Name Segment" (note the capitalization) throughout. Please let
us know which form is preferred.
-->

      <t>The name segment labels specified in this document are given
      in the table below.  Name Segment is a general name segment,
      typically occurring in the routable prefix and user-specified
      content name.  Other segment types are for functional name
      components that imply a specific purpose. </t>


<?rfc compact="no"?>      
      <texttable anchor="name_types" title="CCNx Name-Segment Types">
        <ttcol align="center">Name</ttcol>
        <ttcol align="left">Description</ttcol>
        <c>Name Segment</c>
        <c>A generic name segment that includes arbitrary octets.</c>
        <c>Interest Payload ID</c>
        <c>An octet string that identifies the payload carried in an
        Interest.  As an example, the Payload ID might be a hash of the
        Interest Payload.  This provides a way to differentiate
        between Interests based on the Payload solely through a Name
        Segment without having to include all the extra bytes of the
        payload itself. </c>
        <c>Application Components</c>
        <c>An application-specific payload in a name segment.  An
        application may apply its own semantics to these components.
        A good practice is to identify the application in a Name
        segment prior to the application component segments.</c>
      </texttable>
 <?rfc compact="yes"?>
      <t>At the lowest level, a Forwarder does not need to understand
      the semantics of name segments; it need only identify name
      segment boundaries and be able to compare two name segments
      (both label and value) for equality.  The Forwarder matches
      paths segment by segment against its forwarding table to
      determine a next hop.</t>
      <section anchor="NameExamples" title="Name Examples">
        <t>This section uses the <xref target="ccnx-uri">CCNx
        URI</xref> representation of CCNx names.  Note that as per the
        message grammar, an Interest must have a Name with at least
        one name segment that must have at least 1 octet of value.  A
        Content Object must have a similar name or no name at all.
        The FIB, on the other hand, could have 0-length names (a
        default route), or a first name segment with no value, or a
        regular name.
        </t>
<?rfc compact="no"?>
        <texttable anchor="name_examples" title="CCNx Name Examples">
          <ttcol align="center">Name</ttcol>
          <ttcol align="left">Description</ttcol>
          <c>ccnx:/</c>
          <c>A 0-length name, corresponds to a default route.</c>
          <c>ccnx:/NAME=</c>
          <c>A name with 1 segment of 0 length, distinct from ccnx:/.</c>
          <c>ccnx:/NAME=foo/APP:0=bar</c>
          <c>A 2-segment name, where the first segment is of type NAME and the second
            segment is of type APP:0.</c>
        </texttable>
<?rfc compact="yes"?>
      </section>

<!-- [rfced] This document uses "payload" and "Payload" throughout. Is
there a differentiation between the two to warrant capitalization
of some instances and not others?

Original:
   An Interest may also have a Payload which carries state about the
   Interest but is not used to match a Content Object.  If an Interest
   contains a payload, the Interest name should contain an Interest
   Payload ID (IPID).
-->

      <section anchor="ipid" title="Interest Payload ID">
        <t>An Interest may also have a Payload that carries state
        about the Interest but is not used to match a Content Object.
        If an Interest contains a payload, the Interest name should
        contain an Interest Payload ID (IPID).  The IPID allows a PIT
        table entry to correctly multiplex Content Objects in response
        to a specific Interest with a specific payload ID.  The IPID
        could be derived from a hash of the payload or could be a
        Globally Unique Identifier (GUID) or a nonce.  An optional
        Metadata field defines the IPID field so other systems can
        verify the IPID, such as when it is derived from a hash of the
        payload.  No system is required to verify the IPID.
        </t>
      </section>

    </section>

    <section anchor="cachecontrol" title="Cache Control">
      <t>CCNx supports two fields that affect cache control.  These
      determine how a cache or Content Store handles a Content Object.
      They are not used in the fast path; they are only used to
      determine if a Content Object can be injected onto the fast
      path in response to an Interest.
      </t>
      <t>The ExpiryTime is a field that exists within the signature
      envelope of a Validation Algorithm.  It is the UTC time in
      milliseconds after which the Content Object is considered
      expired and MUST no longer be used to respond to an Interest
      from a cache. Stale content MAY be flushed from the cache.
      </t>

<!-- [rfced] Please verify that the following sentence is correct with
regard to "of low value to cache".

Original:
   It is the UTC time in milliseconds after which
   the publisher considers the Content Object to be of low value to
   cache.

Perhaps:
   It is the UTC time in milliseconds after which
   the publisher considers the Content Object to be of too low a value to
   cache.
 --> 
      <t>The Recommended Cache Time (RCT) is a field that exists
      outside the signature envelope.  It is the UTC time in
      milliseconds after which the publisher considers the Content
      Object to be of low value to cache.  A cache SHOULD discard it
      after the RCT, though it MAY keep it and still respond with it.
      A cache MAY discard the Content Object before the RCT time, too;
      there is no contractual obligation to remember anything.
      </t>
      <t>This formulation allows a producer to create a Content Object
      with a long ExpiryTime but short RCT and keep republishing the
      same signed Content Object over and over again by extending the
      RCT.  This allows a form of "phone home" where the publisher
      wants to periodically see that the content is being used.
      </t>
      </section>

    <section anchor="ConObjHash" title="Content-Object Hash">
        <t>CCNx allows an Interest to restrict a response to a
        specific hash.  The hash covers the Content-Object message
        body and the validation sections, if present. Thus, if a
        Content Object is signed, its hash includes that signature
        value. The hash does not include the fixed or hop-by-hop
        headers of a Content Object. Because it is part of the
        matching rules (see <xref target="matching"/>), the hash is
        used at every hop.
        </t>
        <t>There are two options for matching the Content-Object hash
        restriction in an Interest.  First, a forwarder could compute
        for itself the hash value and compare it to the restriction.
        This is an expensive operation.  The second option is for a
        border device to compute the hash once and place the value in
        a header (ConObjHash) that is carried through the network.
        The second option, of course, removes any security properties
        from matching the hash, so it SHOULD only be used within a
        trusted domain.  The header SHOULD be removed when crossing a
        trust boundary.</t>
      </section>

    <section anchor="link" title="Link">
      <t>A Link is the tuple {Name, [KeyIdRestr],
      [ContentObjectHashRestr]}.  The information in a Link comprises
      the fields of an Interest that would retrieve the Link target.
      A Content Object with PayloadType = "Link" is an object whose
      payload is one or more Links.  This tuple may be used as a
      KeyLink to identify a specific object with the
      certificate-wrapped key.

        It is RECOMMENDED to include at least one of either KeyIdRestr
        or Content ObjectHashRestr.  If neither restriction is
        present, then any Content Object with a matching name from any
        publisher could be returned.
      </t>
    </section>
    <section anchor="hashes" title="Hashes">
      <t>Several protocol fields use cryptographic hash functions,
      which must be secure against attack and collisions.  Because
      these hash functions change over time, with better ones
      appearing and old ones falling victim to attacks, it is
      important that a CCNx protocol implementation supports hash
      agility.</t>
      <t>In this document, we suggest certain hashes (e.g., SHA-256),
      but a specific implementation may use what it deems best. The
      normative <xref target="ccn-messages">CCNx Messages</xref>
      specification should be taken as the definition of acceptable
      hash functions and uses.
      </t>
    </section>

    <section anchor="signature" title="Validation">
      <section anchor="valalg" title="Validation Algorithm">
        <t>The Validator consists of a ValidationAlgorithm that
        specifies how to verify the message and a ValidationPayload
        containing the validation output, e.g., the digital signature
        or MAC.
	The ValidationAlgorithm section defines the type of
        algorithm to use and includes any necessary additional
        information.  The validation is calculated from the beginning
        of the CCNx Message through the end of the ValidationAlgorithm
        section.  The ValidationPayload is the integrity value bytes,
        such as a MAC or signature.</t>
        <t>
          Some Validators contain a KeyId, identifying the publisher
          authenticating the Content Object. If an Interest carries a
          KeyIdRestr, then that KeyIdRestr MUST exactly match the
          Content Object's KeyId.</t>
        
<!-- [rfced] This document expands MIC into both "Message Integrity
Code" and "Message Integrity Check". Is there a preferred
expansion to use throughout or are both correct in their
respective contexts?

Original:
   Validators using Message Integrity Code (MIC) algorithms
   do not need to provide any additional information
   ...
   Chunks may also carry weaker Message Integrity Checks (MICs) or no
   integrity protection mechanism at all. 
-->

<!-- [rfced] Please verify that the expansion for "RSA" is the common
term "Rivest, Shamir and Adleman", the expansion for "DSA" is the
common term "Digital Signature Algorithm", and that ECDSA should
be expanded as "Elliptic Curve Digital Signature Algorithm".

Original:
   Signature validators use public key cryptographic algorithms such as RSA,
   DSA, ECDSA.

Perhaps:
   Signature validators use public key cryptographic algorithms such as RSA,
   DSA, and the Elliptic Curve Digital Signature Algorithm (ECDSA).
-->

<!-- [rfced] Can a signature bundle a Key, a Certificate,
and a Keylink, or should any of those terms be considered a combined entity?

Original:
   A signature may optionally include a KeyLocator, as described above, to
   bundle a Key or Certificate or KeyLink.

Perhaps: 
   A signature may optionally include a KeyLocator, as described above, to
   bundle a Key, Certificate, or KeyLink. 
-->

<!-- [rfced] This document appears to use both "signature" and
"Signature" throughout as used as a technical noun. Is there a
differentiation between uses or should they all follow the same
capitalization?

Original:
   Validation Algorithms fall into three categories: MICs, MACs, and
   Signatures.
   ...
   The KeyId field in the ValidationAlgorithm identifies the public key used
   to verify the signature. 
-->
<t>
          Validation Algorithms fall into three categories: MICs,
          MACs, and Signatures.  Validators using Message Integrity
          Code (MIC) algorithms do not need to provide any additional
          information; they may be computed and verified based only on
          the algorithm (e.g., CRC32C). MAC validators require the use
          of a KeyId identifying the secret key used by the
          authenticator. Because MACs are usually used between two
          parties that have already exchanged secret keys via a key
          exchange protocol, the KeyId may be any agreed-upon value to
          identify which key is used.  Signature validators use public
          key cryptographic algorithms such as RSA, DSA, ECDSA. The
          KeyId field in the ValidationAlgorithm identifies the public
          key used to verify the signature. A signature may optionally
          include a KeyLocator, as described above, to bundle a Key or
          Certificate or KeyLink.  MAC and Signature validators may
          also include a SignatureTime, as described above.
        </t>
        <t>A PublicKeyLocator KeyLink points to a Content Object with
        a DER-encoded X.509 certificate in the payload.  In this case,
        the target KeyId must equal the first object's KeyId.  The
        target KeyLocator must include the public key corresponding to
        the KeyId.  That key must validate the target Signature.  The
        payload is an X.509 certificate whose public key must match
        the target KeyLocator's key.  It must be issued by a trusted
        authority, preferably specifying the valid namespace of the
        key in the distinguished name.
        </t>
      </section>
    </section>
    <section anchor="matching" title="Interest to Content-Object Matching">
      <t>A Content Object satisfies an Interest if and only if (a) the
      Content-Object name, if present, exactly matches the Interest
      name, (b) the ValidationAlgorithm KeyId of the Content Object
      exactly equals the Interest KeyIdRestr, if present, and (c) the
      computed Content ObjectHash exactly equals the Interest
      ContentObjectHashRestr, if present.</t>
      <t>The matching rules
      are given by this predicate, which if it evaluates true means
      the Content Object matches the Interest.  Ni = Name in the
      Interest (may not be empty), Ki = KeyIdRestr in the Interest
      (may be empty), and Hi = ContentObjectHashRestr in the Interest
      (may be empty).  Likewise, No, Ko, and Ho are those properties
      in the Content Object, where No and Ko may be empty; Ho always
      exists (it is an intrinsic property of the Content Object).  For
      binary relations, we use "&amp;" for AND and "|" for OR.  We use
      "E" for the EXISTS (not empty) operator and "!" for the NOT
      EXISTS operator.</t>
      <t>As a special case, if the ContentObjectHashRestr in the
      Interest specifies an unsupported hash algorithm, then no
      Content Object can match the Interest, so the system should drop
      the Interest and MAY send an InterestReturn to the previous hop.
      In this case, the predicate below will never get executed
      because the Interest is never forwarded.  If the system is using
      the optional behavior of having a different system calculate the
      hash for it, then the system may assume all hash functions are
      supported and leave it to the other system to accept or reject
      the Interest.</t>
      <figure>
        <artwork align="left"><![CDATA[
(!No | (Ni=No)) & (!Ki | (Ki=Ko)) & (!Hi | (Hi=Ho)) & (E No | E Hi)
]]></artwork>
      </figure>
      <t>As one can see, there are two types of attributes one can
      match.  The first term depends on the existence of the attribute
      in the Content Object while the next two terms depend on the
      existence of the attribute in the Interest.  The last term is
      the "Nameless Object" restriction that states that if a Content
      Object does not have a Name, then it must match the Interest on
      at least the Hash restriction.</t>
      <t>If a Content Object does not carry the Content ObjectHash as
      an expressed field, it must be calculated in-network to match
      against. It is sufficient within an autonomous system to
      calculate a Content ObjectHash at a border router and carry it
      via trusted means within the autonomous system. If a
      Content-Object ValidationAlgorithm does not have a KeyId, then
      the Content Object cannot match an Interest with a
      KeyIdRestr.</t>
    </section>

    <section anchor="InterestReturn" title="Interest Return">
      <t>This section describes the process whereby a network element
      may return an Interest message to a previous hop if there is an
      error processing the Interest. The returned Interest may be
      further processed at the previous hop or returned towards the
      Interest origin.  When a node returns an Interest, it indicates
      that the previous hop should not expect a response from that
      node for the Interest, i.e., there is no PIT entry left at the
      returning node.</t>
      <t>The returned message maintains compatibility with the
      existing TLV packet format (a fixed header, optional hop-by-hop
      headers, and the CCNx Message body). The returned Interest
      packet is modified in only two ways:
        <list style="symbols">
          <t>The PacketType is set to InterestReturn to indicate a
          Feedback message.
          </t>
          <t>The ReturnCode is set to the appropriate value to signal
          the reason for the return.
          </t>
        </list>
      </t>
      <t>The specific encodings of the Interest Return are specified
      in <xref target="ccn-messages"/>.</t>
      <t>A Forwarder is not required to send any Interest Return messages.</t>
      <t>A Forwarder is not required to process any received Interest
      Return message.  If a Forwarder does not process Interest Return
      messages, it SHOULD silently drop them.</t>
      <t>The Interest Return message does not apply to a Content
      Object or any other message type.</t>
      <t>An Interest Return message is a 1-hop message between peers.
      It is not propagated multiple hops via the FIB.  An intermediate
      node that receives an InterestReturn may take corrective actions
      or may propagate its own InterestReturn to previous hops as
      indicated in the reverse path of a PIT entry.</t>
      <section anchor="MessageFormat" title="Message Format">
        <t>The Interest Return message looks exactly like the original
        Interest message with the exception of the two modifications
        mentioned above.  The PacketType is set to indicate the
        message is an InterestReturn, and the reserved byte in the
        Interest header is used as a Return Code.  The numeric values
        for the PacketType and ReturnCodes are in <xref
        target="ccn-messages"/>.</t>
      </section>
      <section anchor="TypeDefinitions" title="ReturnCode Types">
        <t>This section defines the InterestReturn ReturnCode
        introduced in this RFC.  The numeric values used in the packet
        are defined in <xref target="ccn-messages"/>.</t>

<?rfc compact="no"?>	
        <texttable anchor="ReasonCode" title="Interest Return Reason Codes">
          <ttcol align="left">Name</ttcol>
          <ttcol align="left">Description</ttcol>
          <c>
            <xref target="NoRoute">No Route</xref>
          </c>
          <c>The returning Forwarder has no route to the Interest name.</c>
          <c>
            <xref target="HopLimit">HopLimit Exceeded</xref>
          </c>
          <c>The HopLimit has decremented to 0 and needs to forward the packet.</c>
          <c>
            <xref target="MTU">Interest MTU too large</xref>
          </c>
          <c>The Interest's MTU does not conform to the required
          minimum and would require fragmentation.</c>
          <c>
            <xref target="NoResources">No Resources</xref>
          </c>
          <c>The node does not have the resources to process the Interest.</c>
          <c>
            <xref target="PathError">Path error</xref>
          </c>
          <c>There was a transmission error when forwarding the
          Interest along a route (a transient error).</c>
          <c>
            <xref target="Prohibited">Prohibited</xref>
          </c>
          <c>An administrative setting prohibits processing this Interest.</c>
          <c>
            <xref target="Congestion">Congestion</xref>
          </c>
          <c>The Interest was dropped due to congestion (a transient error).</c>
          <c>
            <xref target="UnsupportedHashAlgorithm">Unsupported
            Content-Object Hash Algorithm</xref>
          </c>
          <c>The Interest was dropped because it requested a
          Content-Object Hash Restriction using a hash algorithm that
          cannot be computed.</c>
          <c>
            <xref target="MalformedInterest">Malformed Interest</xref>
          </c>
          <c>The Interest was dropped because it did not correctly parse.</c>
        </texttable>
<?rfc compact="yes"?>
      </section>
      <section anchor="InterestReturnProtocol" title="Interest Return Protocol">
        <t>This section describes the Forwarder behavior for the
        various Reason codes for Interest Return.  A Forwarder is not
        required to generate any of the codes, but if it does, it MUST
        conform to this specification.</t>
        <t>If a Forwarder receives an Interest Return, it SHOULD take
        these standard corrective actions.  A forwarder is allowed to
        ignore Interest Return messages, in which case its PIT entry
        would go through normal timeout processes.

          <list style="symbols"><t>Verify that the Interest Return
          came from a next hop to which it actually sent the
          Interest.</t><t>If a PIT entry for the corresponding
          Interest does not exist, the Forwarder should ignore the
          Interest Return.</t><t>If a PIT entry for the corresponding
          Interest does exist, the Forwarder MAY do one of the
          following: <list style="symbols"><t>Try a different
          forwarding path, if one exists, and discard the Interest
          Return, or</t><t>Clear the PIT state and send an Interest
          Return along the reverse path.</t></list> </t></list>
        </t>
        <t>If a forwarder tries alternate routes, it MUST ensure that
        it does not use the same path multiple times.  For example, it
        could keep track of which next hops it has tried and not reuse
        them.</t>
        <t>If a forwarder tries an alternate route, it may receive a
        second InterestReturn, possibly of a different type than the
        first InterestReturn.  For example, node A sends an Interest
        to node B, which sends a No Route return.  Node A then tries
        node C, which sends a Prohibited.  Node A should choose what
        it thinks is the appropriate code to send back to its previous
        hop.</t>
        <t>If a forwarder tries an alternate route, it should decrement the Interest Lifetime to account
          for the time spent thus far processing the Interest.</t>
        <section anchor="NoRoute" title="No Route">
          <t>If a Forwarder receives an Interest for which it has no
          route, or for which the only route is back towards the
          system that sent the Interest, the Forwarder SHOULD generate
          a "No Route" Interest Return message.</t>
          <t> How a forwarder manages the FIB table when it receives a
          No Route message is implementation dependent.  In general,
          receiving a No Route Interest Return should not cause a
          forwarder to remove a route.  The dynamic routing protocol
          that installed the route should correct the route, or the
          administrator who created a static route should correct the
          configuration.  A forwarder could suppress using that next
          hop for some period of time.</t>
        </section>
        <section anchor="HopLimit" title="HopLimit Exceeded">
          <t>A Forwarder MAY choose to send HopLimit Exceeded messages when it receives an Interest that must
            be forwarded off system and the HopLimit is 0.</t>
        </section>
<!-- [rfced] How can we update the following sentence for clarity?

Original:
   If a Forwarder receives an "Interest MTU Too Large" is SHOULD NOT try
   alternate paths.

Perhaps:
   If a Forwarder receives an "Interest MTU Too Large" message, it SHOULD NOT try
   alternate paths. 
-->

<!-- [rfced] Can "InterestReturn" stand on its own as a noun or should
instances be changed to "InterestReturn message"?

Original:
   If a Forwarder receives an Interest and it cannot process the
   Interest due to lack of resources, it MAY send an InterestReturn.
-->
        <section anchor="MTU" title="Interest MTU Too Large">
          <t>If a Forwarder receives an Interest whose MTU exceeds the
          prescribed minimum, it MAY send an "Interest MTU Too Large"
          message, or it may silently discard the Interest.</t>
          <t>If a Forwarder receives an "Interest MTU Too Large" is SHOULD NOT try alternate paths.
            It SHOULD propagate the Interest Return to its previous hops.</t>
        </section>
        <section anchor="NoResources" title="No Resources">
          <t>If a Forwarder receives an Interest and it cannot process
          the Interest due to lack of resources, it MAY send an
          InterestReturn.  A lack of resources could mean the PIT
          table is too large or that there is some other capacity
          limit.</t>
        </section>

<!-- [rfced] In the following sentence, should "Interest Return" be made into
"InterestReturn" to match other instances in Section 10?

Original:
   ...it MAY send a Path Error Interest Return indicating
   that it was not able to send or repair a forwarding error.
   ...
   it MAY send a Prohibited InterestReturn to the previous hop   
   ...
   it MAY send a Congestion InterestReturn to the previous hop.
--> 
        <section anchor="PathError" title="Path Error">
          <t>If a forwarder detects an error forwarding an Interest,
          such as over a reliable link, it MAY send a Path-Error
          Interest Return indicating that it was not able to send or
          repair a forwarding error.</t>
        </section>

<!-- [rfced] Would the following sentence benefit from quotation marks around
"/parc/private"?

Original:

   For example, if there is an ACL that says /parc/private can only
   come from interface e0, but the Forwarder receives one from e1, the
   Forwarder must have a way to return the Interest with an
   explanation.

Perhaps:

   For example, if there is an ACL that says "/parc/private" can only
   come from interface e0, but the Forwarder receives one from e1, the
   Forwarder must have a way to return the Interest with an
   explanation.
 -->
        <section anchor="Prohibited" title="Prohibited">
          <t>A forwarder may have administrative policies, such as
          access control lists (ACLs), that prohibit receiving or
          forwarding an Interest.  If a forwarder discards an Interest
          due to a policy, it MAY send a Prohibited InterestReturn to
          the previous hop. For example, if there is an ACL that says
          /parc/private can only come from interface e0, but the
          Forwarder receives one from e1, the Forwarder must have a
          way to return the Interest with an explanation.</t>
        </section>
        <section anchor="Congestion" title="Congestion">
          <t>If a forwarder discards an Interest due to congestion, it MAY send a Congestion InterestReturn to
            the previous hop.</t>
        </section>
        <section anchor="UnsupportedHashAlgorithm" title="Unsupported Content-Object Hash Algorithm">
          <t>If a Content-Object Hash Restriction specifies a hash
          algorithm the forwarder cannot verify, the Interest should
          not be accepted and the forwarder MAY send an InterestReturn
          to the previous hop.</t>
        </section>
        <section anchor="MalformedInterest" title="Malformed Interest">
          <t>If a forwarder detects a structural or syntactical error
          in an Interest, it SHOULD drop the Interest and MAY send an
          InterestReturn to the previous hop.  This does not imply
          that any router must validate the entire structure of an
          Interest.</t>
        </section>
      </section>
    </section>


    <section anchor="IANA" title="IANA Considerations">
      <t>This document has no IANA actions.</t>


    </section>
    <section anchor="Security" title="Security Considerations">
		<t>The CCNx protocol is a L3 network protocol, which
		may also operate as an overlay using other transports
		such as UDP or other tunnels.  It includes intrinsic
		support for message authentication via a signature
		(e.g., RSA or elliptic curve) or message
		authentication code (e.g., HMAC).  In lieu of an
		authenticator, it may instead use a message integrity
		check (e.g., SHA or CRC).  CCNx does not specify an
		encryption envelope; that function is left to a
		high-layer protocol (e.g., <xref target="esic"/>).</t>
		
		<t>
        The CCNx message format includes the ability to attach MICs
        (e.g., SHA-256 or CRC), MACs (e.g., HMAC), and Signatures
        (e.g., RSA or ECDSA) to all packet types.  This does not mean
        that it is a good idea to use an arbitrary
        ValidationAlgorithm, nor to include computationally expensive
        algorithms in Interest packets, as that could lead to
        computational DoS attacks.  Applications should use an
        explicit protocol to guide their use of packet signatures.  As
        a general guideline, an application might use a MIC on an
        Interest to detect unintentionally corrupted packets.  If one
        wishes to secure an Interest, one should consider using an
        encrypted wrapper and a protocol that prevents replay attacks,
        especially if the Interest is being used as an actuator.
        Simply using an authentication code or signature does not make
        an Interest secure.  There are several examples in the
        literature on how to secure ICN-style messaging <xref
        target="mobile"/> <xref target="ace"/>.
        </t>		
		
		<t>As a L3 protocol, this document does not describe
		how one arrives at keys or how one trusts keys.  The
		CCNx Content Object may include a public key embedded
		in the object or may use the PublicKeyLocator field to
		point to a public key (or public key certificate) that
		authenticates the message.  One key-exchange
		specification is <xref target="ccnx-ke">CCNxKE</xref>
		<xref target="mobile"/>, which is similar to the TLS
		1.3 key exchange except it is over the CCNx L3
		messages.  Trust is beyond the scope of a L3 protocol
		and left to applications or application frameworks.
		</t>
		
		<t>
		The combination of an ephemeral key exchange (e.g.,
		<xref target="ccnx-ke">CCNxKE</xref>) and an
		encapsulating encryption (e.g., <xref target="esic"/>)
		provides the equivalent of a TLS tunnel.  Intermediate
		nodes may forward the Interests and Content Objects
		but have no visibility inside.  It also completely
		hides the internal names in those used by the
		encryption layer.  This type of tunneling encryption
		is useful for content that has little or no
		cacheability, as it can only be used by someone with
		the ephemeral key.  Short-term caching may help with
		lossy links or mobility, but long-term caching is
		usually not of interest.
		</t>
		
		<t>Broadcast encryption or proxy re-encryption may be
		useful for content with multiple uses over time or
		many consumers.  There is currently no recommendation
		for this form of encryption.
		</t>

<!-- [rfced] Would parentheses around 'T' and 'L' for their initial use benefit the following
sentence?

Original:
   Some TLVs use variable length T and variable length L
   fields to accomodate a wide gamut of values while trying to be byte-
   efficient.

Perhaps:
   Some TLVs use variable length "T" and variable length "L"
   fields to accomodate a wide gamut of values while trying to be byte-
   efficient.
-->
		<t>The specific encoding of messages will have
		security implications.  <xref target="ccn-messages"/>
		uses a type-length-value (TLV) encoding.  We chose to
		compromise between extensibility and unambiguous
		encodings of types and lengths.  Some TLVs use
		variable length T and variable length L fields to
		accommodate a wide gamut of values while trying to be
		byte-efficient.  Our TLV encoding uses a fixed-length
		2-byte T and 2-byte L.  Using a fixed-length T and L
		field solves two problems.  The first is aliases.  If
		one is able to encode the same value, such as 0x2 and
		0x02, in different byte lengths, then one must decide
		if they mean the same thing, if they are different, or
		if one is illegal.  If they are different, then one
		must always compare on the buffers, not the integer
		equivalents.  If one is illegal, then one must
		validate the TLV encoding, every field of every packet
		at every hop.  If they are the same, then one has the
		second problem: how to specify packet filters.  For
		example, if a name has 6 name components, then there
		are 7 T's and 7 L's, each of which might have up to 4
		representations of the same value.  That would be 14
		fields with 4 encodings each, or 1001 combinations.
		It also means that one cannot compare, for example, a
		name via a memory function as one needs to consider
		that any embedded T or L might have a different
		format.</t>
    		
      <t>The Interest Return message has no authenticator from the
      previous hop.  Therefore, the payload of the Interest Return
      should only be used locally to match an Interest.  A node should
      never forward that Interest payload as an Interest.  It should
      also verify that it sent the Interest in the Interest Return to
      that node and not allow anyone to negate Interest messages.</t>
        
      <t>Caching nodes must take caution when processing Content
      Objects.  It is essential that the Content Store obey the rules
      outlined in <xref target="contentstore"/> to avoid certain types
      of attacks.  Unlike NDN, CCNx 1.0 has no mechanism to work
      around an undesired result from the network (there are no
      "excludes"), so if a cache becomes poisoned with bad content, it
      might cause problems retrieving content.  There are three types
      of access to content from a Content Store: unrestricted,
      signature restricted, and hash restricted.  If an Interest has
      no restrictions, then the requester is not particular about what
      they get back, so any matching cached object is OK.  In the hash
      restricted case, the requester is very specific about what they
      want and the Content Store (and every forward hop) can easily
      verify that the content matches the request.  In the signature
      verified case (often used for initial manifest discovery), the
      requester only knows the KeyId that signed the content.  It is
      this case that requires the closest attention in the Content
      Store to avoid amplifying bad data.  The Content Store must only
      respond with a Content Object if it can verify the signature;
      this means either the Content Object carries the public key
      inside it or the Interest carries the public key in addition to
      the KeyId.  If that is not the case, then the Content Store
      should treat the Interest as a cache miss and let an endpoint
      respond.
      	</t>
      	
       <t>A user-level cache could perform full-signature verification
       by fetching a public key according to the PublicKeyLocator.
       That is not, however, a burden we wish to impose on the
       forwarder.  A user-level cache could also rely on out-of-band
       attestation, such as the cache operator only inserting content
       that it knows has the correct signature.</t>

<!-- [rfced] How might we revise the following sentence for clarity?

Original:
   Some fields, such as the ConObjHash, must be verified at
   each hop, so a forwarder (or related system) must know the hash
   algorithm and it could cause backward compatibility problems if the
   hash type is updated.

Perhaps:

   Some fields, such as the ConObjHash, must be verified at each hop,
   so a forwarder (or related system) must know the hash algorithm and
   whether or not it could cause backward compatibility problems if
   the hash type is updated.
-->
      <t>The CCNx grammar allows for hash-algorithm agility via the
      HashType.  It specifies a short list of acceptable hash
      algorithms that should be implemented at each forwarder.  Some
      hash values only apply to end systems, so updating the hash
      algorithm does not affect forwarders; they would simply match
      the buffer that includes the type-length-hash buffer.  Some
      fields, such as the ConObjHash, must be verified at each hop, so
      a forwarder (or related system) must know the hash algorithm and
      it could cause backward compatibility problems if the hash type
      is updated.  <xref target="ccn-messages"/> is the authoritative
      source for per-field-allowed hash types in that encoding.</t>
      
      <t>A CCNx name uses binary matching whereas a URI uses a
      case-insensitive hostname.  Some systems may also use
      case-insensitive matching of the URI path to a resource.  An
      implication of this is that human-entered CCNx names will likely
      have case or non-ASCII symbol mismatches unless one uses a
      consistent URI normalization to the CCNx name.  It also means
      that an entity that registers a CCNx routable prefix, say
      "ccnx:/example.com", would need separate registrations for
      simple variations like "ccnx:/Example.com".  Unless this
      is addressed in URI normalization and routing protocol
      conventions, there could be phishing attacks.</t>
          
       <t>For a more general introduction to ICN-related security concerns and approaches,
       see <xref target="RFC7927"/> and <xref target="RFC7945"/>.</t>
    </section>
  </middle>
  <back>
    <references title="Normative References">

      &RFC2119;
      &RFC8174;
    </references>
    <references title="Informative References">

      &RFC5234;

      <reference anchor="dart" target="https://arxiv.org/pdf/1603.06044.pdf">
          <front>
              <title>A Light-Weight Forwarding Plane for Content-Centric Networks</title>
              <author initials="J.J." surname="Garcia-Luna-Aceves"><organization>PARC, Inc.</organization></author>
              <author initials="M." surname="Mirzazad-Barijough"><organization>University of California, Santa Cruz</organization></author>
              <date month="February" year="2016"/>
          </front>
<seriesInfo name="International Conference on Computing, Networking, and
Communications" value="(ICNC)"/>
<seriesInfo name="DOI" value="10.1109/ICCNC.2016.7440637"/>
      </reference>

	<reference anchor="trust" target="https://doi.org/10.1109/ICCCN.2016.7568589">
		<front>
			<title>Trust in Information-Centric Networking: From Theory to Practice</title>
			<author initials="C." surname="Tschudin"><organization>University of Basel</organization></author>
			<author initials="E." surname="Uzun"><organization>PARC, Inc.</organization></author>
			<author initials="C." surname="Wood"><organization>University of California, Irvine</organization></author>
              <date month="August" year="2016"/>			
		</front>
<seriesInfo name="25th International Conference on Computer
		  Communication and Networks" value="(ICCCN)"/>
<seriesInfo name="DOI" value="10.1109/ICCCN.2016.7568589"/>

	</reference>
	
      <reference anchor="ndn"
		 target="http://www.named-data.net"><front><title>Named Data
      Networking</title><author><organization></organization></author><date
      /></front></reference> 


<!-- [rfced] We note that draft-irtf-icnrg-ccnxmessages is currently
in our queue (in EDIT state).  We have left the reference
pointing to the Work in Progress (Internet-Draft) version so as
not to slow publication.  Please let us know if it is preferrable
to wait for that document to clear the queue to reference the RFC
number it will be assigned instead.

-->

<!-- draft-irtf-icnrg-ccnxmessages-08: Expired -->
      <reference anchor="ccn-messages">
          <front>
              <title>CCNx Messages in TLV Format</title>
              <author initials="M." surname="Mosko" fullname="Marc Mosko"><organization>PARC, Inc.</organization></author>
              <author initials="I." surname="Solis" fullname="Ignacio Solis"><organization>LinkedIn</organization></author>
              <author initials="C." surname="Wood" fullname="Christopher A. Wood"><organization>University
	      of California, Irvine</organization></author> 
              <date month="January" year="2019"/>
          </front>
<seriesInfo name='Work in Progress,' value='draft-irtf-icnrg-ccnxmessages-09'/>
      </reference>

     <reference anchor="mobile" target="http://dl.ifip.org/db/conf/networking/networking2017/1570334964.pdf">
          <front>
              <title>Mobile Sessions in Content-Centric Networks</title>
              <author initials="M." surname="Mosko" fullname="Marc Mosko"><organization>PARC, Inc.</organization></author>
              <author initials="E." surname="Uzun" fullname="Ersin Uzun"><organization>PARC, Inc.</organization></author>
              <author initials="C." surname="Wood" fullname="Christopher A. Wood"><organization>University of California, Irvine</organization></author>
              <date month="June" year="2017"/>
          </front>
          <seriesInfo name="IFIP Networking Conference (IFIP Networking)
			    and" value="Workshops"/>
<seriesInfo name="DOI" value="10.23919/IFIPNetworking.2017.8264861"/>
      </reference>

     <reference anchor="ace" target="http://new.named-data.net/wp-content/uploads/2015/12/ndn-0036-1-ndn-ace.pdf">
          <front>
              <title>NDN-ACE: Access Control for Constrained Environments over Named Data Networking</title>
              <author initials="W." surname="Shang"><organization>University of California, Los Angeles</organization></author>
              <author initials="Y." surname="Yu"><organization>University of California, Los Angeles</organization></author>
              <author initials="T." surname="Liang"><organization>University of Arizona</organization></author>
              <author initials="B." surname="Zhang"><organization>University of Arizona</organization></author>
              <author initials="L." surname="Zhang"><organization>University of California, Los Angeles</organization></author>
              <date month="December" year="2015"/>
          </front>
          <seriesInfo name="NDN Technical Report" value="NDN-0036"/>
      </reference>

<!-- draft-wood-icnrg-ccnxkeyexchange-02: Expired --> 
     <reference anchor="ccnx-ke">
          <front>
              <title>CCNx Key Exchange Protocol Version 1.0</title>
              <author initials="M." surname="Mosko" fullname="Marc Mosko"><organization>PARC, Inc.</organization></author>
              <author initials="E." surname="Uzun" fullname="Ersin Uzun"><organization>PARC, Inc.</organization></author>
              <author initials="C." surname="Wood" fullname="Christopher A. Wood"><organization>University of California, Irvine</organization></author>
              <date month="March" year="2017"/>
          </front>
<seriesInfo name='Work in Progress,' value='draft-wood-icnrg-ccnxkeyexchange-02'/>
      </reference>

<!-- [rfced] The following reference appears to be an entry on GitHub,
though there is an older version that is also an expired
Internet-Draft. See
<https://datatracker.ietf.org/doc/draft-mosko-icnrg-selectors/>.

Would you like to reference the expired Internet-Draft or update
the reference to adhere to the Web-Based Public Code Repositories
format? See <https://www.rfc-editor.org/styleguide/part2/>.

Original:
     [selectors]
              Mosko, M., "CCNx Selector Based Discovery", 2017,
              <https://raw.githubusercontent.com/mmosko/ccnx-protocol-
              rfc/master/docs/build/draft-mosko-icnrg-selectors-01.txt>.

Perhaps:
     [selectors]
             "CCNx Selector Based Discovery", July 2018,
	     <https://raw.githubusercontent.com/mmosko/ccnx-protocol-rfc/master/docs/build/draft-mosko-icnrg-selectors-01.txt> 
--> 

     <reference anchor="selectors" target="https://raw.githubusercontent.com/mmosko/ccnx-protocol-rfc/master/docs/build/draft-mosko-icnrg-selectors-01.txt">
          <front>
              <title>CCNx Selector Based Discovery</title>
              <author initials="M." surname="Mosko" fullname="Marc Mosko"><organization>PARC, Inc.</organization></author>
              <date year="2018"/>
          </front>
      </reference>

<!-- draft-mosko-icnrg-ccnxchunking-02: Expired --> 
     <reference anchor="chunking">
          <front>
              <title>CCNx Content Object Chunking</title>
              <author initials="M." surname="Mosko" fullname="Marc Mosko"><organization>PARC, Inc.</organization></author>
              <date month="June" year="2016"/>
          </front>
<seriesInfo name="Work in Progress," value="draft-mosko-icnrg-ccnxchunking-02"/>

      </reference>

<!-- draft-mosko-icnrg-beginendfragment-02: Expired --> 
     <reference anchor="befrags">
          <front>
              <title>ICN "Begin-End" Hop by Hop Fragmentation</title>
              <author initials="M." surname="Mosko" fullname="Marc Mosko"><organization>PARC, Inc.</organization></author>
              <author initials="C." surname="Tschudin" fullname="Christian Tschudin"><organization>University of Basel</organization></author>
              <date month="December" year="2016"/>
          </front>
<seriesInfo name='Work in Progress,' value='draft-mosko-icnrg-beginendfragment-02'/>
      </reference>

<!-- draft-tschudin-icnrg-flic-03: Expired --> 
     <reference anchor="flic">
          <front>
              <title>File-Like ICN Collection (FLIC)</title>
              <author initials="C." surname="Tschudin" fullname="Christian Tschudin"><organization>University of Basel</organization></author>
              <author initials="C." surname="Wood" fullname="Christopher A. Wood"><organization>University of California, Irvine</organization></author>
              <date month="March" year="2017"/>
          </front>
<seriesInfo name='Work in Progress,' value="draft-tschudin-icnrg-flic-03" />
      </reference>

<!-- [rfced] We have updated this reference entry as follows. Please confirm
that this update is correct. We could not locate a draft named
draft-mosko-icnrg-ccnxuri, but draft-mosko-icnrg-ccnxurischeme has the
same author list and title (though a different year).

Original:
   [CCNxURI]  Mosko, M. and C. Wood, "The CCNx URI Scheme (Internet
              draft)", 2017,
              <http://tools.ietf.org/html/draft-mosko-icnrg-ccnxuri-02>.

Updated:
   [ccnx-uri]  Mosko, M. and C. Wood, "The CCNx URI Scheme", Work in
              Progress, draft-mosko-icnrg-ccnxurischeme-01, April 2016.
-->

<!-- draft-mosko-icnrg-ccnxurischeme-01: Expired --> 
      <reference anchor="ccnx-uri">
          <front>
              <title>The CCNx URI Scheme</title>
              <author initials="M." surname="Mosko" fullname="Marc Mosko"><organization>PARC, Inc.</organization></author>
              <author initials="C." surname="Wood" fullname="Christopher A. Wood"><organization>University of California, Irvine</organization></author>
              <date month="April" year="2016"/>
          </front>
<seriesInfo name="Work in Progress," value="draft-mosko-icnrg-ccnxurischeme-01"/>
      </reference>

<!-- draft-wood-icnrg-esic-01: Expired --> 
      <reference anchor="esic">
          <front>
              <title>Encrypted Sessions In CCNx (ESIC)</title>
              <author initials="M." surname="Mosko" fullname="Marc Mosko"><organization>PARC, Inc.</organization></author>
              <author initials="C." surname="Wood" fullname="Christopher A. Wood"><organization>University of California, Irvine</organization></author>
              <date month= "September" year="2017"/>
          </front>
<seriesInfo name="Work in Progress," value="draft-wood-icnrg-esic-01"/>
      </reference>


<!-- [rfced] FYI: The following reference for [cnnlite] has been updated per
the "Web-Based Public Code Repositories" reference format. See
<https://www.rfc-editor.org/styleguide/part2/>. Please let us know if this is
not preferred.
Note: Please let us know if the github page for "CCN-Lite V3" was
intended. See <https://github.com/cn-uofbasel/ccn-lite/releases/tag/0.3.0>

Original:
    [ccnlite]  Tschudin, C., et al., University of Basel, "CCN-Lite V2",
              2011-2018, <http://www.ccn-lite.net/>.

Currently:
    [ccn-lite]  Computer Networks Group, University of Basel, "CCN-lite",
              <ccn-lite.net>.
-->

      <reference anchor="ccn-lite" target="ccn-lite.net">
      	<front>
      		<title>CCN-lite</title>
      		<author><organization>Computer Networks Group, University of Basel</organization></author>
      		<date />
      	</front>
      </reference>


      <reference anchor="cicn" target="https://wiki.fd.io/index.php?title=Cicn&amp;oldid=7191">
      	<front>
      		<title>Community ICN (CICN)</title>
      		<author><organization>FD.io</organization></author>
      		<date month="February" year="2017"/>
      	</front>
      </reference>
      
      <reference anchor="nnc" target="http://dx.doi.org/10.1145/1658939.1658941">
      	<front>
      		<title>Networking Named Content</title>
      		<author initials="V." surname="Jacobson" fullname="Van Jacobson"><organization>Palo Alto Research Center</organization></author>
      		<author initials="D.K." surname="Smetters" fullname="Diana K. Smetters"><organization>Palo Alto Research Center</organization></author>
      		<author initials="J.D." surname="Thornton" fullname="James D. Thornton"><organization>Palo Alto Research Center</organization></author>
      		<author initials="M.F." surname="Plass" fullname="Michael F. Plass"><organization>Palo Alto Research Center</organization></author>
      		<author initials="N.H." surname="Briggs" fullname="Nicholas H. Briggs"><organization>Palo Alto Research Center</organization></author>
      		<author initials="R.L." surname="Braynard" fullname="Rebecca L. Braynard"><organization>Palo Alto Research Center</organization></author>
      		<date month="December" year="2009"/>
      	</front>

<seriesInfo name="Proceedings of the 5th International Conference
		  on Emerging Networking Experiments and"
	    value="Technologies"/>

<seriesInfo name="DOI" value="10.1145/1658939.1658941"/>

      </reference>
<?rfc include="reference.RFC.7945" ?>      
<?rfc include="reference.RFC.7927" ?>



<!-- draft-irtf-icnrg-terminology-01: I-D exists -->
      <reference anchor="terminology">
      	<front>
      		<title>Information-Centric Networking (ICN): CCN and NDN Terminology</title>
      		<author initials="B." surname="Wissingh"><organization>TNO</organization></author>
      		<author initials="C." surname="Wood"><organization>University of California Irvine</organization></author>
      		<author initials="A." surname="Afanasyev"><organization>UCLA</organization></author>
      		<author initials="L." surname="Zhang"><organization>UCLA</organization></author>
      		<author initials="D." surname="Oran"><organization>Network Systems Research &amp; Design</organization></author>
      		<author initials="C." surname="Tschudin"><organization>University of Basel</organization></author>
      		<date month="March" year="2019"/>
      	</front>
<seriesInfo name="Work in Progress," value="draft-irtf-icnrg-terminology-01" />
      </reference>
      
    <reference anchor="eprise-numbers" target="http://www.iana.org/assignments/enterprise-numbers/enterprise-numbers">
        <front>
          <title>IANA Private Enterprise Numbers</title>
          <author>
            <organization>IANA</organization>
          </author>

          <date />
        </front>
      </reference>

    </references>
<!-- [rfced] We had the following questions that affected more
than one portion of the document.

a) Throughout the text, we see the use of "PIT table".  As the "T"
stands for "Table", please let us know if these should be updated.

b) We see the terms "Interest" and "Content Object" introduced in
several places.  Is this repetition necessary/desirable?  (Basically,
Section 2 seems to be already covered in the text that precedes it.)
-->


  </back>
</rfc>
