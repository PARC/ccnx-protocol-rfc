<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>CCNx Semantics</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Architecture">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Protocol Overview">
<link href="#rfc.section.2" rel="Chapter" title="2 Protocol">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Message Grammar">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Consumer Behavior">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Publisher Behavior">
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Forwarder Behavior">
<link href="#rfc.section.2.4.1" rel="Chapter" title="2.4.1 Interest HopLimit">
<link href="#rfc.section.2.4.2" rel="Chapter" title="2.4.2 Interest Aggregation">
<link href="#rfc.section.2.4.3" rel="Chapter" title="2.4.3 Content Store Behavior">
<link href="#rfc.section.2.4.4" rel="Chapter" title="2.4.4 Interest Pipeline">
<link href="#rfc.section.2.4.5" rel="Chapter" title="2.4.5 Content Object Pipeline">
<link href="#rfc.section.3" rel="Chapter" title="3 Names">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Name Examples">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Interest Payload ID">
<link href="#rfc.section.4" rel="Chapter" title="4 Cache Control">
<link href="#rfc.section.5" rel="Chapter" title="5 Content Object Hash">
<link href="#rfc.section.6" rel="Chapter" title="6 Link">
<link href="#rfc.section.7" rel="Chapter" title="7 Hashes">
<link href="#rfc.section.8" rel="Chapter" title="8 Validation">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Validation Algorithm">
<link href="#rfc.section.9" rel="Chapter" title="9 Interest to Content Object matching">
<link href="#rfc.section.10" rel="Chapter" title="10 Interest Return">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Message Format">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 ReturnCode Types">
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Interest Return Protocol">
<link href="#rfc.section.10.3.1" rel="Chapter" title="10.3.1 No Route">
<link href="#rfc.section.10.3.2" rel="Chapter" title="10.3.2 HopLimit Exceeded">
<link href="#rfc.section.10.3.3" rel="Chapter" title="10.3.3 Interest MTU Too Large">
<link href="#rfc.section.10.3.4" rel="Chapter" title="10.3.4 No Resources">
<link href="#rfc.section.10.3.5" rel="Chapter" title="10.3.5 Path Error">
<link href="#rfc.section.10.3.6" rel="Chapter" title="10.3.6 Prohibited">
<link href="#rfc.section.10.3.7" rel="Chapter" title="10.3.7 Congestion">
<link href="#rfc.section.10.3.8" rel="Chapter" title="10.3.8 Unsupported Content Object Hash Algorithm">
<link href="#rfc.section.10.3.9" rel="Chapter" title="10.3.9 Malformed Interest">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.12" rel="Chapter" title="12 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="13 References">
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.3 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Mosko, M., Solis, I., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-irtf-icnrg-ccnxsemantics-11" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-09" />
  <meta name="dct.abstract" content="This document describes the core concepts of the Content Centric Networking (CCNx) architecture and presents a network protocol based on two messages: Interests and Content Objects.  It specifies the set of mandatory and optional fields within those messages and describes their behavior and interpretation. This architecture and protocol specification is independent of a specific wire encoding.The protocol also uses a Control message called an InterestReturn, whereby one system can return an Interest message to the previous hop due to an error condition.  This indicates to the previous hop that the current system will not respond to the Interest.This document is a product of the Information Centric Networking research group (ICNRG)." />
  <meta name="description" content="This document describes the core concepts of the Content Centric Networking (CCNx) architecture and presents a network protocol based on two messages: Interests and Content Objects.  It specifies the set of mandatory and optional fields within those messages and describes their behavior and interpretation. This architecture and protocol specification is independent of a specific wire encoding.The protocol also uses a Control message called an InterestReturn, whereby one system can return an Interest message to the previous hop due to an error condition.  This indicates to the previous hop that the current system will not respond to the Interest.This document is a product of the Information Centric Networking research group (ICNRG)." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">ICNRG</td>
<td class="right">M. Mosko</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">PARC, Inc.</td>
</tr>
<tr>
<td class="left">Intended status: Experimental</td>
<td class="right">I. Solis</td>
</tr>
<tr>
<td class="left">Expires: November 10, 2019</td>
<td class="right">LinkedIn</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of California Irvine</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">May 9, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">CCNx Semantics<br />
  <span class="filename">draft-irtf-icnrg-ccnxsemantics-11</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes the core concepts of the Content Centric Networking (CCNx) architecture and presents a network protocol based on two messages: Interests and Content Objects.  It specifies the set of mandatory and optional fields within those messages and describes their behavior and interpretation. This architecture and protocol specification is independent of a specific wire encoding.</p>
<p>The protocol also uses a Control message called an InterestReturn, whereby one system can return an Interest message to the previous hop due to an error condition.  This indicates to the previous hop that the current system will not respond to the Interest.</p>
<p>This document is a product of the Information Centric Networking research group (ICNRG).</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on November 10, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Architecture</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Protocol Overview</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Protocol</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Message Grammar</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Consumer Behavior</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Publisher Behavior</a>
</li>
<li>2.4.   <a href="#rfc.section.2.4">Forwarder Behavior</a>
</li>
<ul><li>2.4.1.   <a href="#rfc.section.2.4.1">Interest HopLimit</a>
</li>
<li>2.4.2.   <a href="#rfc.section.2.4.2">Interest Aggregation</a>
</li>
<li>2.4.3.   <a href="#rfc.section.2.4.3">Content Store Behavior</a>
</li>
<li>2.4.4.   <a href="#rfc.section.2.4.4">Interest Pipeline</a>
</li>
<li>2.4.5.   <a href="#rfc.section.2.4.5">Content Object Pipeline</a>
</li>
</ul></ul><li>3.   <a href="#rfc.section.3">Names</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Name Examples</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Interest Payload ID</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Cache Control</a>
</li>
<li>5.   <a href="#rfc.section.5">Content Object Hash</a>
</li>
<li>6.   <a href="#rfc.section.6">Link</a>
</li>
<li>7.   <a href="#rfc.section.7">Hashes</a>
</li>
<li>8.   <a href="#rfc.section.8">Validation</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Validation Algorithm</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Interest to Content Object matching</a>
</li>
<li>10.   <a href="#rfc.section.10">Interest Return</a>
</li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Message Format</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">ReturnCode Types</a>
</li>
<li>10.3.   <a href="#rfc.section.10.3">Interest Return Protocol</a>
</li>
<ul><li>10.3.1.   <a href="#rfc.section.10.3.1">No Route</a>
</li>
<li>10.3.2.   <a href="#rfc.section.10.3.2">HopLimit Exceeded</a>
</li>
<li>10.3.3.   <a href="#rfc.section.10.3.3">Interest MTU Too Large</a>
</li>
<li>10.3.4.   <a href="#rfc.section.10.3.4">No Resources</a>
</li>
<li>10.3.5.   <a href="#rfc.section.10.3.5">Path Error</a>
</li>
<li>10.3.6.   <a href="#rfc.section.10.3.6">Prohibited</a>
</li>
<li>10.3.7.   <a href="#rfc.section.10.3.7">Congestion</a>
</li>
<li>10.3.8.   <a href="#rfc.section.10.3.8">Unsupported Content Object Hash Algorithm</a>
</li>
<li>10.3.9.   <a href="#rfc.section.10.3.9">Malformed Interest</a>
</li>
</ul></ul><li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<li>12.   <a href="#rfc.section.12">Security Considerations</a>
</li>
<li>13.   <a href="#rfc.references">References</a>
</li>
<ul><li>13.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This document describes the principles of the CCNx architecture. It describes a network protocol that uses a hierarchical name to forward requests and to match responses to requests.  It does not use endpoint addresses, such as Internet Protocol.  Restrictions in a request can limit the response by the public key of the response's signer or the cryptographic hash of the response.  Every CCNx forwarder along the path does the name matching and restriction checking.  The CCNx protocol fits within the broader framework of Information Centric Networking (ICN) protocols <a href="#RFC7927" class="xref">[RFC7927]</a>.  This document concerns the semantics of the protocol and is not dependent on a specific wire format encoding.  The <a href="#CCNMessages" class="xref">CCNx Messages</a> document describes a type-length-value (TLV) wire protocol encoding.  This section introduces the main concepts of CCNx, which are further elaborated in the remainder of the document.  </p>
<p id="rfc.section.1.p.2">The CCNx protocol derives from the early ICN work by <a href="#nnc" class="xref">Jacobson et al.</a>.  Jacobson's version of CCNx is known as the 0.x version ("CCNx 0.x") and the present work is known as the 1.0 version ("CCNx 1.0").  There are two active implementations of CCNx 1.0.  The most complete implementation is <a href="#cicn" class="xref">Community ICN (CINC)</a>, a Linux Foundation project hosted at fd.io.  Another active implementation is <a href="#ccnlite" class="xref">CCN-lite</a>, with support for IoT systems and the RIOT operating system.  CCNx 0.x formed the basis of the <a href="#ndn" class="xref">Named Data Networking</a> (NDN) university project.  </p>
<p id="rfc.section.1.p.3">The current CCNx 1.0 specification diverges from CCNx 0.x in a few significant areas.  The most pronounced behavioral difference between CCNx 0.x and CCNx 1.0 is that CCNx 1.0 has a simpler response processing behavior.  In both versions, a forwarder uses a hierarchical longest prefix match of a request name against the forwarding information base (FIB) to send the request through the network to a system that can issue a response.  A forwarder must then match a response's name to a request's name to determine the reverse path and deliver the response to the requester.  In CCNx 0.x, the Interest name may be a hierarchical prefix of the response name, which allows a form of layer 3 content discovery.  In CCNx 1.0, a response's name must exactly equal a request's name.  Content discovery is performed by a higher-layer protocol.  </p>
<p><a href="#selectors" class="xref">CCNx Selectors</a> is an example of using a higher-layer protocol on top of the CCNx 1.0 layer-3 to perform content discovery.  The selector protocol uses a method similar to the original CCNx 0.x techniques without requiring partial name matching of a response to a request in the forwarder.</p>
<p id="rfc.section.1.p.5">The document represents the consensus of the ICN RG.  It is the first ICN protocol from the RG, created from the early CCNx protocol <a href="#nnc" class="xref">[nnc]</a> with significant revision and input from the ICN community and RG members.  The draft has received critical reading by several members of the ICN community and the RG.  The authors and RG chairs approve of the contents.  The document is sponsored under the IRTF and is not issued by the IETF and is not an IETF standard.  This is an experimental protocol and may not be suitable for any specific application and the specification may change in the future.  </p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">RFC 2119</a>.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Architecture</h1>
<p id="rfc.section.1.2.p.1">We describe the architecture of the network in which CCNx operates and introduce certain terminology from <a href="#terminology" class="xref">[terminology]</a>.  The detailed behavior of each component and message grammars are in <a href="#protocol" class="xref">Section 2</a>.</p>
<p id="rfc.section.1.2.p.2">A producer (also called a publisher) is an endpoint that encapsualtes content in Content Objects for transport in the CCNx network.  A producer has a public/private keypair and signs (directly or indirectly) the content objects.  Usually, the producer's keyid (hash of the public key) is well-known or may be derived from the producer's namespace via standard means.</p>
<p id="rfc.section.1.2.p.3">A producer operates within one or more namespaces.  A namespace is a name prefix that is represented in the forwarding information base (FIB).  This allows a request to reach the producer and fetch a response (if one exists).</p>
<p id="rfc.section.1.2.p.4">The forwarding information base (FIB) is a table that tells a forwarder where to send a request.  It may point to a local application, a local cache or content store, or to a remote system.  If there is no matching entry in the FIB, a forwarder cannot process a request.  The detailed rules on name matching to the FIB are given in <a href="#interest_pipe" class="xref">Section 2.4.4</a>.  An endpoint has a FIB, though it may be a simple default route.  An intermediate system (i.e. a router) typically has a much larger FIB.  A core CCNx forwarder, for example, would know all the global routes.  </p>
<p id="rfc.section.1.2.p.5">A consumer is an endpoint that requests a name.  It is beyond the scope of this document to describe how a consumer learns of a name or publisher keyid -- higher layer protocols build on top of CCNx handle those tasks, such as search engines or lookup services or well known names.  The consumer constructs a request, called an Interest, and forwards it via the endpoint's FIB.  The consumer should get back either a response, called a Content Object, that matches the Interest or a control message, called an InterestReturn, that indicates the network cannot handle the request.</p>
<p id="rfc.section.1.2.p.6">There are three ways to detect errors in Interest handling.  An InterestReturn is a network control message that indicates a low-level error like no route or out of resources.  If an Interest arrives at a producer, but the producer does not have the requested content, the producer should send an application-specific error message (e.g. a not found message).  Finally, a consumer may not receive anything, in which case it should timeout and, depending on the application, retry the request or return an error to the application.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Protocol Overview</h1>
<p id="rfc.section.1.3.p.1">The goal of CCNx is to name content and retrieve the content from the network without binding it to a specific network endpoint.  A routing system (specified separately) populates the forwarding information base (FIB) tables at each CCNx router with hierarchical name prefixes that point towards the content producers under that prefix.  A request finds matching content along those paths, in which case a response carries the data, or if no match is found a control message indicates the failure.  A request may further refine acceptable responses with a restriction on the response's signer and the cryptographic hash of the response.  The details of these restrictions are described below.  </p>
<p id="rfc.section.1.3.p.2">The CCNx name is a hierarchical series of path segments.  Each path segment has a type and zero or more bytes.  Matching two names is done as a binary comparison of the type and value, segment by segment.  The human-readable form is defined under a URI scheme <a href="#CCNxURI" class="xref">"ccnx:"</a>, though the canonical encoding of a name is a series of (type, octet string) pairs.  There is no requirement that any path segment be human readable or UTF-8.  The first few segments in a name will matched against the FIB and a routing protocol may put its own restrictions on the routable name components (e.g. a maximum length or character encoding rules).  In principle, path segments and names have unbounded length, though in practice they are limited by the wire format encoding and practical considerations imposed by a routing protocol.  Note that in CCNx path segments use binary comparison whereas in a URI the authority uses case-insensitive hostname (due to DNS).</p>
<p id="rfc.section.1.3.p.3">The CCNx name, as used by the forwarder, is purposefully left as a general octet-encoded type and value without any requirements on human readability and character encoding.  The reason for this is that we are concerned with how a forwarder processes names.  We expect that applications, routing protocols, or other higher layers will apply their own conventions and restrictions on the allowed path segment types and path segment values.</p>
<p id="rfc.section.1.3.p.4">CCNx is a request and response protocol to fetch chunks of data using a name. The integrity of each chunk may be directly asserted through a digital signature or Message Authentication Code (MAC), or, alternatively, indirectly via hash chains. Chunks may also carry weaker message integrity checks (MICs) or no integrity protection mechanism at all.  Because provenance information is carried with each chunk (or larger indirectly protected block), we no longer need to rely on host identities, such as those derived from TLS certificates, to ascertain the chunk legitimacy. Data integrity is therefore a core feature of CCNx; it does not rely on the data transmission channel. There are several options for data confidentiality, discussed later.  </p>
<p id="rfc.section.1.3.p.5">This document only defines the general properties of CCNx names.  In some isolated environments, CCNx users may be able to use any name they choose and either inject that name (or prefix) into a routing protocol or use other information foraging techniques.  In the Internet environment, there will be policies around the formats of names and assignments of names to publishers, though those are not specified here.  </p>
<p id="rfc.section.1.3.p.6">The key concept of CCNx is that a subjective name is cryptographically bound to a fixed payload. These publisher-generated bindings can therefore be cryptographically verified.  A named payload is thus the tuple {{Name, ExtraFields, Payload, ValidationAlgorithm}, ValidationPayload}, where all fields in the inner tuple are covered by the validation payload (e.g. signature).  Consumers of this data can check the binding integrity by re-computing the same cryptographic hash and verifying the digital signature in ValidationPayload.  </p>
<p id="rfc.section.1.3.p.7">In addition to digital signatures (e.g. RSA), CCNx also supports message authentication codes (e.g. HMAC) and message integrity codes (e.g. SHA-256 or CRC).  To maintain the cryptographic binding, there should be at least one object with a signature or authentication code, but not all objects require it.  For example, a first object with a signature could refer to other objects via a hash chain, a Merkle tree, or a signed manifest.  The later objects may not have any validation and rely purely on the references.  The use of an integrity code (e.g. CRC) is intended for detecting accidental corruption in an Interest.  </p>
<p id="rfc.section.1.3.p.8">CCNx specifies a network protocol around Interests (request messages) and Content Objects (response messages) to move named payloads.  An Interest includes the Name -- which identifies the desired response -- and optional matching restrictions.  Restrictions limit the possible matching Content Objects. Two restrictions exist: KeyIdRestr and ContentObjectHashRestr. The first restriction on the KeyId limits responses to those signed with a ValidationAlgorithm KeyId field equal to the restriction.  The second is the Content ObjectHash restriction, which limits the response to one where the cryptographic hash of the entire named payload is equal to the restriction.  </p>
<p id="rfc.section.1.3.p.9">The hierarchy of a CCNx Name is used for routing via the longest matching prefix in a Forwarder.  The longest matching prefix is computed name segment by name segment in the hierarchical path name, where each name segment must be exactly equal to match.  There is no requirement that the prefix be globally routable.  Within a deployment any local routing may be used, even one that only uses a single flat (non-hierarchical) name segment.  </p>
<p id="rfc.section.1.3.p.10">Another concept of CCNx is that there should be flow balance between Interest messages and Content Object messages.  At the network level, an Interest traveling along a single path should elicit no more than one Content Object response.  If some node sends the Interest along more than one path, that node should consolidate the responses such that only one Content Object flows back towards the requester.  If an Interest is sent broadcast or multicast on a multiple-access media, the sender should be prepared for multiple responses unless some other media-dependent mechanism like gossip suppression or leader election is used.  </p>
<p id="rfc.section.1.3.p.11">As an Interest travels the forward path following the Forwarding Information Base (FIB), it establishes state at each forwarder such that a Content Object response can trace its way back to the original requester(s) without the requester needing to include a routable return address.  We use the notional Pending Interest Table (PIT) as a method to store state that facilitates the return of a Content Object.  </p>
<p id="rfc.section.1.3.p.12">The notional PIT table stores the last hop of an Interest plus its Name and optional restrictions.  This is the data required to match a Content Object to an Interest (see <a href="#matching" class="xref">Section 9</a>).  When a Content Object arrives, it must be matched against the PIT to determine which entries it satisfies.  For each such entry, at most one copy of the Content Object is sent to each listed last hop in the PIT entries.  </p>
<p id="rfc.section.1.3.p.13">An actual PIT table is not mandated by the specification.  An implementation may use any technique that gives the same external behavior.  There are, for example, research papers that use techniques like label switching in some parts of the network to reduce the per-node state incurred by the PIT table <a href="#dart" class="xref">[dart]</a>.  Some implementations store the PIT state in the FIB, so there is not a second table.</p>
<p id="rfc.section.1.3.p.14">If multiple Interests with the same {Name, KeyIdRestr, ContentObjectHashRestr} tuple arrive at a node before a Content Object matching the first Interest comes back, they are grouped in the same PIT entry and their last hops aggregated (see <a href="#aggregation" class="xref">Section 2.4.2</a>).  Thus, one Content Object might satisfy multiple pending Interests in a PIT.  </p>
<p id="rfc.section.1.3.p.15">In CCNx, higher-layer protocols are often called "name-based protocols" because they operate on the CCNx Name.  For example, a versioning protocol might append additional name segments to convey state about the version of payload.  A content discovery protocol might append certain protocol-specific name segments to a prefix to discover content under that prefix.  Many such protocols may exist and apply their own rules to Names. They may be layered with each protocol encapsulating (to the left) a higher layer's Name prefix.  </p>
<p id="rfc.section.1.3.p.16">This document also describes a control message called an InterestReturn.  A network element may return an Interest message to a previous hop if there is an error processing the Interest. The returned Interest may be further processed at the previous hop or returned towards the Interest origin.  When a node returns an Interest it indicates that the previous hop should not expect a response from that node for the Interest, i.e., there is no PIT entry left at the returning node for a Content Object to follow.  </p>
<p id="rfc.section.1.3.p.17">There are multiple ways to describe larger objects in CCNx.  Aggregating layer-3 content objects in to larger objects is beyond the scope of this document.  One proposed method, <a href="#flic" class="xref">FLIC</a>, uses a manifest to enumerate the pieces of a larger object.  Manifests are, themselves, Content Objects.  Another option is to use a convention in the Content Object name, as in the <a href="#chunking" class="xref">CCNx Chunking</a> protocol where a large object is broken in to small chunks and each chunk receives a special name component indicating its serial order.  </p>
<p id="rfc.section.1.3.p.18">At the semantic level, described in this document, we do not address fragmentation.  One experimental fragmentation protocol, <a href="#befrags" class="xref">BeginEnd Fragments</a> uses a multipoint-PPP style technique  for use over layer-2 interfaces with the <a href="#CCNMessages" class="xref">CCNx Messages</a> TLV wire forman specification.  </p>
<p id="rfc.section.1.3.p.19">With these concepts, the remainder of the document specifies the behavior of a forwarder in processing Interest, Content Object, and InterestReturn messages.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#protocol" id="protocol">Protocol</a>
</h1>
<p id="rfc.section.2.p.1">CCNx is a request and response protocol. A request is called an Interest and a response is called a Content Object.  CCNx also uses a 1-hop control message called InterestReturn.  These are, as a group, called CCNx Messages.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#grammar" id="grammar">Message Grammar</a>
</h1>
<p id="rfc.section.2.1.p.1">The CCNx message <a href="#RFC5234" class="xref">ABNF</a> grammar is shown in <a href="#abnfgrammar" class="xref">Figure 1</a>.  The grammar does not include any encoding delimiters, such as TLVs.  Specific wire encodings are given in a separate document.  If a Validation section exists, the Validation Algorithm covers from the Body (BodyName or BodyOptName) through the end of the ValidationAlg section.  The InterestLifetime, CacheTime, and Return Code fields exist outside of the validation envelope and may be modified.  </p>
<p id="rfc.section.2.1.p.2">The various fields -- in alphabetical order -- are defined as: </p>

<ul>
<li>AbsTime: Absolute times are conveyed as the 64-bit UTC time in milliseconds since the epoch (standard POSIX time).  </li>
<li>CacheTime: The absolute time after which the publisher believes there is low value in caching the content object.  This is a recommendation to caches (see <a href="#cachecontrol" class="xref">Section 4</a>).  </li>
<li>ConObjField: These are optional fields that may appear in a Content Object.  </li>
<li>ConObjHash: The value of the Content Object Hash, which is the SHA256-32 over the message from the beginning of the body to the end of the message.  Note that this coverage area is different from the ValidationAlg.  This value SHOULD NOT be trusted across domains (see <a href="#ConObjHash" class="xref">Section 5</a>).  </li>
<li>ExpiryTime: An absolute time after which the content object should be considered expired (see <a href="#cachecontrol" class="xref">Section 4</a>).  </li>
<li>Hash: Hash values carried in a Message carry a HashType to identify the algorithm used to generate the hash followed by the hash value.  This form is to allow hash agility.  Some fields may mandate a specific HashType.  </li>
<li>HopLimit: Interest messages may loop if there are loops in the forwarding plane.  To eventually terminate loops, each Interest carries a HopLimit that is decremented after each hop and no longer forwarded when it reaches zero.  See <a href="#forwarder" class="xref">Section 2.4</a>.  </li>
<li>InterestField: These are optional fields that may appear in an Interest message.  </li>
<li>KeyIdRestr: The KeyId Restriction.  A Content Object must have a KeyId with the same value as the restriction.  </li>
<li>ContentObjectHashRestr: The Content Object Hash Restriction.  A content object must hash to the same value as the restriction using the same HashType.  The ContentObjectHashRestr MUST use SHA256-32.  </li>
<li>KeyId: An identifier for the key used in the ValidationAlg.  For public key systems, this should be the SHA-256 hash of the public key.  For symmetric key systems, it should be an identifier agreed upon by the parties.  </li>
<li>KeyLink: A Link (see <a href="#link" class="xref">Section 6</a>) that names how to retrieve the key used to verify the ValidationPayload.  A message SHOULD NOT have both a KeyLink and a PublicKey.  </li>
<li>Lifetime: The approximate time during which a requester is willing to wait for a response, usually measured in seconds.  It is not strongly related to the network round trip time, though it must necessarily be larger.  </li>
<li>Name: A name is made up of a non-empty first segment followed by zero or more additional segments, which may be of 0 length.  Path segments are opaque octet strings, and are thus case-sensitive if encoding UTF-8.  An Interest MUST have a Name.  A Content Object MAY have a Name (see <a href="#matching" class="xref">Section 9</a>).  The segments of a name are said to be complete if its segments uniquely identify a single Content Object. A name is exact if its segments are complete. An Interest carrying a full name is one which specifies an exact name and the ContentObjectHashRestr of the corresponding Content Object.  </li>
<li>Payload: The message's data, as defined by PayloadType.  </li>
<li>PayloadType: The format of the Payload.  If missing, assume DataType.  DataType means the payload is opaque application bytes.  KeyType means the payload is a DER-encoded public key.  LinkType means it is one or more Links (see <a href="#link" class="xref">Section 6</a>).  </li>
<li>PublicKey: Some applications may wish to embed the public key used to verify the signature within the message itself.  The PublickKey is DER encoded.  A message SHOULD NOT have both a KeyLink and a PublicKey.  </li>
<li>RelTime: A relative time, measured in milli-seconds.  </li>
<li>ReturnCode: States the reason an Interest message is being returned to the previous hop (see <a href="#TypeDefinitions" class="xref">Section 10.2</a>).  </li>
<li>SigTime: The absolute time (UTC milliseconds) when the signature was generated.  </li>
<li>Vendor: Vendor-specific opaque data.  The Vendor data includes the <a href="#EpriseNumbers" class="xref">IANA Private Enterprise Numbers</a>, followed by vendor-specific information.  CCNx allows vendor-specific data in most locations of the grammar.  </li>
</ul>

<p> </p>
<div id="rfc.figure.1"></div>
<div id="abnfgrammar"></div>
<pre>
Message       := Interest / ContentObject / InterestReturn
Interest      := IntHdr BodyName [Validation]
IntHdr        := HopLimit [Lifetime] *Vendor
ContentObject := ConObjHdr BodyOptName [Validation]
ConObjHdr     := [CacheTime / ConObjHash] *Vendor
InterestReturn:= ReturnCode Interest
BodyName      := Name Common
BodyOptName   := [Name] Common
Common        := *Field [Payload]
Validation    := ValidationAlg ValidatonPayload

Name          := FirstSegment *Segment
FirstSegment  := 1* OCTET / Vendor
Segment       := 0* OCTET / Vendor

ValidationAlg := (RSA-SHA256 / HMAC-SHA256 / CRC32C) *Vendor
ValidatonPayload := 1* OCTET
RSA-SHA256    := KeyId [PublicKey] [SigTime] [KeyLink]
HMAC-SHA256   := KeyId [SigTime] [KeyLink]
CRC32C        := [SigTime]

AbsTime       := 8 OCTET ; 64-bit UTC msec since epoch
CacheTime     := AbsTime
ConObjField   := ExpiryTime / PayloadType
ConObjHash    := Hash ; The Content Object Hash
DataType      := "1"
ExpiryTime    := AbsTime
Field         := InterestField / ConObjField / Vendor
Hash          := HashType 1* OCTET
HashType      := SHA256-32 / SHA512-64 / SHA512-32
HopLimit      := OCTET
InterestField := KeyIdRestr / ContentObjectHashRestr
KeyId         := 1* OCTET ; key identifier
KeyIdRestr    := 1* OCTET
KeyLink       := Link
KeyType       := "2"
Lifetime      := RelTime
Link          := Name [KeyIdResr] [ContentObjectHashRestr]
LinkType      := "3"
ContentObjectHashRestr  := Hash
Payload       := *OCTET
PayloadType   := DataType / KeyType / LinkType
PublicKey     := ; DER-encoded public key
RelTime       := 1* OCTET ; msec
ReturnCode    := ; see Section 10.2
SigTime       := AbsTime
Vendor        := PEN 0* OCTET
PEN           := ; IANA Private Enterprise Number
</pre>
<p class="figure">Figure 1</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#consumer" id="consumer">Consumer Behavior</a>
</h1>
<p id="rfc.section.2.2.p.1">To request a piece of content for a given {Name, [KeyIdRest], [ContentObjectHashRestr]} tuple, a consumer creates an Interest message with those values.  It MAY add a validation section, typically only a CRC32C.  A consumer MAY put a Payload field in an Interest to send additional data to the producer beyond what is in the Name.  The Name is used for routing and may be remembered at each hop in the notional PIT table to facilitate returning a content object; Storing large amounts of state in the Name could lead to high memory requirements.  Because the Payload is not considered when forwarding an Interest or matching a Content Object to an Interest, a consumer SHOULD put an Interest Payload ID (see <a href="#ipid" class="xref">Section 3.2</a>) as part of the name to allow a forwarder to match Interests to content objects and avoid aggregating Interests with different payloads. Similarly, if a consumer uses a MAC or a signature, it SHOULD also include a unique segment as part of the name to prevent the Interest from being aggregated with other Interests or satisfied by a Content Object that has no relation to the validation.  </p>
<p id="rfc.section.2.2.p.2">The consumer SHOULD specify an InterestLifetime, which is the length of time the consumer is willing to wait for a response.  The InterestLifetime is an application-scale time, not a network round trip time (see <a href="#aggregation" class="xref">Section 2.4.2</a>).  If not present, the InterestLifetime will use a default value (2 seconds).  </p>
<p id="rfc.section.2.2.p.3">The consumer SHOULD set the Interest HopLimit to a reasonable value or use the default 255.  If the consumer knows the distances to the producer via routing, it SHOULD use that value.  </p>
<p id="rfc.section.2.2.p.4">A consumer hands off the Interest to its first forwarder, which will then forward the Interest over the network to a publisher (or replica) that may satisfy it based on the name (see <a href="#forwarder" class="xref">Section 2.4</a>).  </p>
<p id="rfc.section.2.2.p.5">Interest messages are unreliable.  A consumer SHOULD run a transport protocol that will retry the Interest if it goes unanswered, up to the InterestLifetime.  No transport protocol is specified in this document.  </p>
<p id="rfc.section.2.2.p.6">The network MAY send to the consumer an InterestReturn message that indicates the network cannot fulfill the Interest.  The ReturnCode specifies the reason for the failure, such as no route or congestion.  Depending on the ReturnCode, the consumer MAY retry the Interest or MAY return an error to the requesting application.  </p>
<p id="rfc.section.2.2.p.7">If the content was found and returned by the first forwarder, the consumer will receive a Content Object.  The consumer SHOULD: </p>

<ul>
<li>Ensure the content object is properly formatted.  </li>
<li>Verify that the returned Name matches a pending request.  If the request also had KeyIdRestr or ObjHashRest, it MUST also validate those properties.  </li>
<li>If the content object is signed, it SHOULD cryptographically verify the signature.  If it does not have the corresponding key, it SHOULD fetch the key, such as from a key resolution service or via the KeyLink.  </li>
<li>If the signature has a SigTime, the consumer MAY use that in considering if the signature is valid.  For example, if the consumer is asking for dynamically generated content, it should expect the SigTime to not be before the time the Interest was generated.  </li>
<li>If the content object is signed, it should assert the trustworthiness of the signing key to the namespace.  Such an assertion is beyond the scope of this document, though one may use traditional PKI methods, a trusted key resolution service, or methods like <a href="#trust" class="xref">[trust]</a>.  </li>
<li>It MAY cache the content object for future use, up to the ExpiryTime if present.  </li>
<li>A consumer MAY accept a content object off the wire that is expired.  It may happen that a packet expires while in flight, and there is no requirement that forwarders drop expired packets in flight.  The only requirement is that content stores, caches, or producers MUST NOT respond with an expired content object.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#publisher" id="publisher">Publisher Behavior</a>
</h1>
<p id="rfc.section.2.3.p.1">This document does not specify the method by which names populate a Forwarding Information Base (FIB) table at forwarders (see <a href="#forwarder" class="xref">Section 2.4</a>).  A publisher is either configured with one or more name prefixes under which it may create content, or it chooses its name prefixes and informs the routing layer to advertise those prefixes.  </p>
<p id="rfc.section.2.3.p.2">When a publisher receives an Interest, it SHOULD: </p>

<ul>
<li>Verify that the Interest is part of the publishers namespace(s).  </li>
<li>If the Interest has a Validation section, verify the ValidationPayload.  Usually an Interest will only have a CRC32C unless the publisher application specifically accommodates other validations.  The publisher MAY choose to drop Interests that carry a Validation section if the publisher application does not expect those signatures as this could be a form of computational denial of service.  If the signature requires a key that the publisher does not have, it is NOT RECOMMENDED that the publisher fetch the key over the network, unless it is part of the application's expected behavior.  </li>
<li>Retrieve or generate the requested content object and return it to the Interest's previous hop.  If the requested content cannot be returned, the publisher SHOULD reply with an InterestReturn or a content object with application payload that says the content is not available; this content object should have a short ExpiryTime in the future or not be cacheable (i.e. an expiry time of 0).  </li>
</ul>

<p> </p>
<h1 id="rfc.section.2.4">
<a href="#rfc.section.2.4">2.4.</a> <a href="#forwarder" id="forwarder">Forwarder Behavior</a>
</h1>
<p id="rfc.section.2.4.p.1">A forwarder routes Interest messages based on a Forwarding Information Base (FIB), returns Content Objects that match Interests to the Interest's previous hop, and processes InterestReturn control messages.  It may also keep a cache of Content Objects in the notional Content Store table.  This document does not specify the internal behavior of a forwarder -- only these and other external behaviors.  </p>
<p id="rfc.section.2.4.p.2">In this document, we will use two processing pipelines, one for Interests and one for Content Objects.  Interest processing is made up of checking for duplicate Interests in the PIT (see <a href="#aggregation" class="xref">Section 2.4.2</a>), checking for a cached Content Object in the Content Store (see <a href="#contentstore" class="xref">Section 2.4.3</a>), and forwarding an Interest via the FIB.  Content Store processing is made up of checking for matching Interests in the PIT and forwarding to those previous hops.  </p>
<h1 id="rfc.section.2.4.1">
<a href="#rfc.section.2.4.1">2.4.1.</a> <a href="#hoplimit" id="hoplimit">Interest HopLimit</a>
</h1>
<p id="rfc.section.2.4.1.p.1">Interest looping is not prevented in CCNx. An Interest traversing loops is eventually discarded using the hop-limit field of the Interest, which is decremented at each hop traversed by the Interest.  </p>
<p id="rfc.section.2.4.1.p.2">A loop may also terminate because the Interest is aggregated with it's previous PIT entry along the loop.  In this case, the Content will be sent back along the loop and eventually return to a node that already forwarded the content, so it will likely not have a PIT entry any more. When the content reaches a node without a PIT entry, it will be discarded.  It may be that a new Interest or another looped Interest will return to that same node, in which case the node will either return a cached response to make a new PIT entry, as below.  </p>
<p id="rfc.section.2.4.1.p.3">The HopLimit is the last resort method to stop Interest loops where a Content Object chases an Interest around a loop and where the intermediate nodes, for whatever reason, no longer have a PIT entry and do not cache the Content Object.  </p>
<p id="rfc.section.2.4.1.p.4">Every Interest MUST carry a HopLimit.  An Interest received from a local application MAY have a 0 HopLimit, which restricts the Interest to other local sources.  </p>
<p id="rfc.section.2.4.1.p.5">When an Interest is received from another forwarder, the HopLimit MUST be positive, otherwise the forwarder will discard the Interest.  A forwarder MUST decrement the HopLimit of an Interest by at least 1 before it is forwarded.  </p>
<p id="rfc.section.2.4.1.p.6">If the decremented HopLimit equals 0, the Interest MUST NOT be forwarded to another forwarder; it MAY be sent to a local publisher application or serviced from a local Content Store.  </p>
<p id="rfc.section.2.4.1.p.7">A RECOMMENDED HopLimit processing pipeline is below: </p>

<ul>
<li>If Interest received from a remote system: <ul>
<li>If received HopLimit is 0, optionally send InterestReturn (HopLimit Exceeded), and discard Interest.</li>
<li>Otherwise, decrement the HopLimit by 1.</li>
</ul>
<p> </p>
</li>
<li>Process as per Content Store and Aggregation rules.</li>
<li>If the Interest will be forwarded: <ul>
<li>If the (potentailly decremented) HopLimit is 0, restrict forwarding to the local system.</li>
<li>Otherwise, forward as desired to local or remote systems.</li>
</ul>
<p> </p>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.2.4.2">
<a href="#rfc.section.2.4.2">2.4.2.</a> <a href="#aggregation" id="aggregation">Interest Aggregation</a>
</h1>
<p id="rfc.section.2.4.2.p.1">Interest aggregation is when a forwarder receives an Interest message that could be satisfied by the response to another Interest message already forwarded by the node, so the forwarder suppresses forwarding the new Interest; it only records the additional previous hop so a Content Object sent in response to the first Interest will satisfy both Interests.  </p>
<p id="rfc.section.2.4.2.p.2">CCNx uses an Interest aggregation rule that assumes the InterestLifetime is akin to a subscription time and is not a network round trip time.  Some previous aggregation rules assumed the lifetime was a round trip time, but this leads to problems of expiring an Interest before a response comes if the RTT is estimated too short or interfering with an ARQ scheme that wants to re-transmit an Interest but a prior interest over-estimated the RTT.  </p>
<p id="rfc.section.2.4.2.p.3">A forwarder MAY implement an Interest aggregation scheme.  If it does not, then it will forward all Interest messages.  This does not imply that multiple, possibly identical, Content Objects will come back.  A forwarder MUST still satisfy all pending Interests, so one Content Object could satisfy multiple similar interests, even if the forwarded did not suppress duplicate Interest messages.  </p>
<p id="rfc.section.2.4.2.p.4">A RECOMMENDED Interest aggregation scheme is: </p>

<ul>
<li>Two Interests are considered 'similar' if they have the same Name, KeyIdRestr, and ContentObjectHashRestr.  </li>
<li>Let the notional value InterestExpiry (a local value at the forwarder) be equal to the receive time plus the InterestLifetime (or a platform-dependent default value if not present).  </li>
<li>An Interest record (PIT entry) is considered invalid if its InterestExpiry time is in the past.  </li>
<li>The first reception of an Interest MUST be forwarded.  </li>
<li>A second or later reception of an Interest similar to a valid pending Interest from the same previous hop MUST be forwarded.  We consider these a retransmission requests.  </li>
<li>A second or later reception of an Interest similar to a valid pending Interest from a new previous hop MAY be aggregated (not forwarded).  If this Interest has a larger HopLimit than the pending Interest, it MUST be forwarded.  </li>
<li>Aggregating an Interest MUST extend the InterestExpiry time of the Interest record.  An implementation MAY keep a single InterestExpiry time for all previous hops or MAY keep the InterestExpiry time per previous hop.  In the first case, the forwarder might send a Content Object down a path that is no longer waiting for it, in which case the previous hop (next hop of the Content Object) would drop it.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.2.4.3">
<a href="#rfc.section.2.4.3">2.4.3.</a> <a href="#contentstore" id="contentstore">Content Store Behavior</a>
</h1>
<p id="rfc.section.2.4.3.p.1">The Content Store is a special cache that is an integral part of a CCNx forwarder.  It is an optional component.  It serves to repair lost packets and handle flash requests for popular content.  It could be pre-populated or use opportunistic caching.  Because the Content Store could serve to amplify an attack via cache poisoning, there are special rules about how a Content Store behaves.  </p>

<ol>
<li>A forwarder MAY implement a Content Store.  If it does, the Content Store matches a Content Object to an Interest via the normal matching rules (see <a href="#matching" class="xref">Section 9</a>).  </li>
<li>If an Interest has a KeyIdRestr, then the Content Store MUST NOT reply unless it knows the signature on the matching Content Object is correct.  It may do this by external knowledge (i.e., in a managed network or system with pre-populated caches) or by having the public key and cryptographically verifying the signature.  A Content Store is NOT REQURIED to verify signatures; if it does not, then it treats these cases like a cache miss.  </li>
<li>If a Content Store chooses to verify signatures, then it MAY do so as follows.  If the public key is provided in the Content Object itself (i.e., in the PublicKey field) or in the Interest, the Content Store MUST verify that the public key's SHA-256 hash is equal to the KeyId and that it verifies the signature.  A Content Store MAY verify the digital signature of a Content Object before it is cached, but it is not required to do so.  A Content Store SHOULD NOT fetch keys over the network.  If it cannot or has not yet verified the signature, it should treat the Interest as a cache miss.  </li>
<li>If an Interest has an ContentObjectHashRestr, then the Content Store MUST NOT reply unless it knows the the matching Content Object has the correct hash.  If it cannot verify the hash, then it should treat the Interest as a cache miss.  </li>
<li>It must obey the Cache Control directives (see <a href="#cachecontrol" class="xref">Section 4</a>).  </li>
</ol>

<p> </p>
<h1 id="rfc.section.2.4.4">
<a href="#rfc.section.2.4.4">2.4.4.</a> <a href="#interest_pipe" id="interest_pipe">Interest Pipeline</a>
</h1>
<p></p>

<ol>
<li>Perform the HopLimit check (see <a href="#hoplimit" class="xref">Section 2.4.1</a>).  </li>
<li>Determine if the Interest can be aggregated, as per <a href="#aggregation" class="xref">Section 2.4.2</a>.  If it can be, aggregate and do not forward the Interest.  </li>
<li>If forwarding the Interest, check for a hit in the Content Store, as per <a href="#contentstore" class="xref">Section 2.4.3</a>.  If a matching Content Object is found, return it to the Interest's previous hop.  This injects the Content Store as per <a href="#object_pipe" class="xref">Section 2.4.5</a>.  </li>
<li>Lookup the Interest in the FIB.  Longest prefix match (LPM) is performed name segment by name segment (not byte or bit).  It SHOULD exclude the Interest's previous hop.  If a match is found, forward the Interest.  If no match is found or the forwarder choses to not forward due to a local condition (e.g., congestion), it SHOULD send an InterestReturn message, as per <a href="#InterestReturn" class="xref">Section 10</a>.</li>
</ol>

<p> </p>
<h1 id="rfc.section.2.4.5">
<a href="#rfc.section.2.4.5">2.4.5.</a> <a href="#object_pipe" id="object_pipe">Content Object Pipeline</a>
</h1>
<p></p>

<ol>
<li>It is RECOMMENDED that a forwarder that receives a content object check that the Content Object came from an expected previous hop.  An expected previous hop is one pointed to by the FIB or one recorded in the PIT as having had a matching Interest sent that way.  </li>
<li>A Content Object MUST be matched to all pending Interests that satisfy the matching rules (see <a href="#matching" class="xref">Section 9</a>).  Each satisfied pending Interest MUST then be removed from the set of pending Interests.  </li>
<li>A forwarder SHOULD NOT send more then one copy of the received Content Object to the same Interest previous hop.  It may happen, for example, that two Interest ask for the same Content Object in different ways (e.g., by name and by name an KeyId) and that they both come from the same previous hop.  It is normal to send the same content object multiple times on the same interface, such as Ethernet, if it is going to different previous hops.  </li>
<li>A Content Object SHOULD only be put in the Content Store if it satisfied an Interest (and passed rule #1 above).  This is to reduce the chances of cache poisoning.  </li>
</ol>

<p> </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#names" id="names">Names</a>
</h1>
<p id="rfc.section.3.p.1">A CCNx name is a composition of name segments. Each name segment carries a label identifying the purpose of the name segment, and a value.  For example, some name segments are general names and some serve specific purposes, such as carrying version information or the sequencing of many chunks of a large object into smaller, signed Content Objects.</p>
<p id="rfc.section.3.p.2">There are three different types of names in CCNx: prefix, exact, and full names.  A prefix name is simply a name that does not uniquely identify a single Content Object, but rather a namespace or prefix of an existing Content Object name.  An exact name is one which uniquely identifies the name of a Content Object.  A full name is one which is exact and is accompanied by an explicit or implicit ConObjHash.  The ConObjHash is explicit in an Interest and implicit in a Content Object.</p>
<p id="rfc.section.3.p.3">Note that a forwarder does not need to know any semantics about a name.  It only needs to be able to match a prefix to forward Interests and match an exact or full name to forward Content Objects.  It is not sensitive to the name segment types.  </p>
<p id="rfc.section.3.p.4">The name segment labels specified in this document are given in the table below.  Name Segment is a general name segment, typically occurring in the routable prefix and user-specified content name.  Other segment types are for functional name components that imply a specific purpose. </p>
<div id="rfc.table.1"></div>
<div id="name_types"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>CCNx Name Segment Types</caption>
<thead><tr>
<th class="center">Name</th>
<th class="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td class="center">Name Segment</td>
<td class="left">A generic name segment that includes arbitrary octets.</td>
</tr>
<tr>
<td class="center">Interest Payload ID</td>
<td class="left">An octet string that identifies the payload carried in an Interest. As an example, the Payload ID might be a hash of the Interest Payload.  This provides a way to differentiate between Interests based on the Payload solely through a Name Segment without having to include all the extra bytes of the payload itself. </td>
</tr>
<tr>
<td class="center">Application Components</td>
<td class="left">An application-specific payload in a name segment.  An application may apply its own semantics to these components.  A good practice is to identify the application in a Name segment prior to the application component segments.</td>
</tr>
</tbody>
</table>
<p id="rfc.section.3.p.5">At the lowest level, a Forwarder does not need to understand the semantics of name segments; it need only identify name segment boundaries and be able to compare two name segments (both label and value) for equality.  The Forwarder matches paths segment-by-segment against its forwarding table to determine a next hop.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#NameExamples" id="NameExamples">Name Examples</a>
</h1>
<p id="rfc.section.3.1.p.1">This section uses the <a href="#CCNxURI" class="xref">CCNx URI</a> representation of CCNx names.  Note that as per the message grammar, an Interest must have a Name with at least one name segment and that name segment must have at least 1 octet of value.  A Content Object must have a similar name or no name at all.  The FIB, on the other hand, could have 0-length names (a default route), or a first name segment with no value, or a regular name.  </p>
<div id="rfc.table.2"></div>
<div id="name_examples"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>CCNx Name Examples</caption>
<thead><tr>
<th class="center">Name</th>
<th class="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td class="center">ccnx:/</td>
<td class="left">A 0-length name, corresponds to a default route.</td>
</tr>
<tr>
<td class="center">ccnx:/NAME=</td>
<td class="left">A name with 1 segment of 0 length, distinct from ccnx:/.</td>
</tr>
<tr>
<td class="center">ccnx:/NAME=foo/APP:0=bar</td>
<td class="left">A 2-segment name, where the first segment is of type NAME and the second segment is of type APP:0.</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#ipid" id="ipid">Interest Payload ID</a>
</h1>
<p id="rfc.section.3.2.p.1">An Interest may also have a Payload which carries state about the Interest but is not used to match a Content Object.  If an Interest contains a payload, the Interest name should contain an Interest Payload ID (IPID).  The IPID allows a PIT table entry to correctly multiplex Content Objects in response to a specific Interest with a specific payload ID.  The IPID could be derived from a hash of the payload or could be a GUID or a nonce.  An optional Metadata field defines the IPID field so other systems could verify the IPID, such as when it is derived from a hash of the payload.  No system is required to verify the IPID.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#cachecontrol" id="cachecontrol">Cache Control</a>
</h1>
<p id="rfc.section.4.p.1">CCNx supports two fields that affect cache control.  These determine how a cache or Content Store handles a Content Object.  They are not used in the fast path, but only to determine if a Content Object can be injected on to the fast path in response to an Interest.  </p>
<p id="rfc.section.4.p.2">The ExpiryTime is a field that exists within the signature envelope of a Validation Algorithm.  It is the UTC time in milliseconds after which the Content Object is considered expired and MUST no longer be used to respond to an Interest from a cache. Stale content MAY be flushed from the cache.  </p>
<p id="rfc.section.4.p.3">The Recommended Cache Time (RCT) is a field that exists outside the signature envelope.  It is the UTC time in milliseconds after which the publisher considers the Content Object to be of low value to cache.  A cache SHOULD discard it after the RCT, though it MAY keep it and still respond with it.  A cache MAY discard the content object before the RCT time too; there is no contractual obligation to remember anything.  </p>
<p id="rfc.section.4.p.4">This formulation allows a producer to create a Content Object with a long ExpiryTime but short RCT and keep re-publishing the same, signed, Content Object over and over again by extending the RCT.  This allows a form of "phone home" where the publisher wants to periodically see that the content is being used.  </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#ConObjHash" id="ConObjHash">Content Object Hash</a>
</h1>
<p id="rfc.section.5.p.1">CCNx allows an Interest to restrict a response to a specific hash.  The hash covers the Content Object message body and the validation sections, if present. Thus, if a Content Object is signed, its hash includes that signature value. The hash does not include the fixed or hop-by-hop headers of a Content Object. Because it is part of the matching rules (see <a href="#matching" class="xref">Section 9</a>), the hash is used at every hop.  </p>
<p id="rfc.section.5.p.2">There are two options for matching the content object hash restriction in an Interest.  First, a forwarder could compute for itself the hash value and compare it to the restriction.  This is an expensive operation.  The second option is for a border device to compute the hash once and place the value in a header (ConObjHash) that is carried through the network.  The second option, of course, removes any security properties from matching the hash, so SHOULD only be used within a trusted domain.  The header SHOULD be removed when crossing a trust boundary.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#link" id="link">Link</a>
</h1>
<p id="rfc.section.6.p.1">A Link is the tuple {Name, [KeyIdRestr], [ContentObjectHashRestr]}.  The information in a Link comprises the fields of an Interest which would retrieve the Link target.  A Content Object with PayloadType = "Link" is an object whose payload is one or more Links.  This tuple may be used as a KeyLink to identify a specific object with the certificate wrapped key.  It is RECOMMENDED to include at least one of KeyIdRestr or Content ObjectHashRestr.  If neither restriction is present, then any Content Object with a matching name from any publisher could be returned.  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#hashes" id="hashes">Hashes</a>
</h1>
<p id="rfc.section.7.p.1">Several protocol fields use cryptographic hash functions, which must be secure against attack and collisions.  Because these hash functions change over time, with better ones appearing and old ones falling victim to attacks, it is important that a CCNx protocol implementation supports hash agility.</p>
<p id="rfc.section.7.p.2">In this document, we suggest certain hashes (e.g., SHA-256), but a specific implementation may use what it deems best. The normative <a href="#CCNMessages" class="xref">CCNx Messages</a> specification should be taken as the definition of acceptable hash functions and uses.  </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#signature" id="signature">Validation</a>
</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#valalg" id="valalg">Validation Algorithm</a>
</h1>
<p id="rfc.section.8.1.p.1">The Validator consists of a ValidationAlgorithm that specifies how to verify the message and a ValidationPayload containing the validation output, e.g., the digital signature or MAC.  The ValidationAlgorithm section defines the type of algorithm to use and includes any necessary additional information.  The validation is calculated from the beginning of the CCNx Message through the end of the ValidationAlgorithm section.  The ValidationPayload is the integrity value bytes, such as a MAC or signature.</p>
<p id="rfc.section.8.1.p.2">Some Validators contain a KeyId, identifying the publisher authenticating the Content Object. If an Interest carries a KeyIdRestr, then that KeyIdRestr MUST exactly match the Content Object's KeyId.</p>
<p id="rfc.section.8.1.p.3">Validation Algorithms fall into three categories: MICs, MACs, and Signatures.  Validators using Message Integrity Code (MIC) algorithms do not need to provide any additional information; they may be computed and verified based only on the algorithm (e.g., CRC32C). MAC validators require the use of a KeyId identifying the secret key used by the authenticator. Because MACs are usually used between two parties that have already exchanged secret keys via a key exchange protocol, the KeyId may be any agreed-upon value to identify which key is used.  Signature validators use public key cryptographic algorithms such as RSA, DSA, ECDSA. The KeyId field in the ValidationAlgorithm identifies the public key used to verify the signature. A signature may optionally include a KeyLocator, as described above, to bundle a Key or Certificate or KeyLink.  MAC and Signature validators may also include a SignatureTime, as described above.  </p>
<p id="rfc.section.8.1.p.4">A PublicKeyLocator KeyLink points to a Content Object with a DER-encoded X509 certificate in the payload.  In this case, the target KeyId must equal the first object's KeyId.  The target KeyLocator must include the public key corresponding to the KeyId.  That key must validate the target Signature.  The payload is an X.509 certificate whose public key must match the target KeyLocator's key.  It must be issued by a trusted authority, preferably specifying the valid namespace of the key in the distinguished name.  </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#matching" id="matching">Interest to Content Object matching</a>
</h1>
<p id="rfc.section.9.p.1">A Content Object satisfies an Interest if and only if (a) the Content Object name, if present, exactly matches the Interest name, and (b) the ValidationAlgorithm KeyId of the Content Object exactly equals the Interest KeyIdRestr, if present, and (c) the computed Content ObjectHash exactly equals the Interest ContentObjectHashRestr, if present.</p>
<p id="rfc.section.9.p.2">The matching rules are given by this predicate, which if it evaluates true means the Content Object matches the Interest.  Ni = Name in Interest (may not be empty), Ki = KeyIdRestr in the interest (may be empty), Hi = ContentObjectHashRestr in Interest (may be empty).  Likewise, No, Ko, Ho are those properties in the Content Object, where No and Ko may be empty; Ho always exists (it is an intrinsic property of the Content Object).  For binary relations, we use &amp; for AND and | for OR.  We use E for the EXISTS (not empty) operator and ! for the NOT EXISTS operator.</p>
<p id="rfc.section.9.p.3">As a special case, if the ContentObjectHashRestr in the Interest specifies an unsupported hash algorithm, then no Content Object can match the Interest so the system should drop the Interest and MAY send an InterestReturn to the previous hop.  In this case, the predicate below will never get executed because the Interest is never forwarded.  If the system is using the optional behavior of having a different system calculate the hash for it, then the system may assume all hash functions are supported and leave it to the other system to accept or reject the Interest.</p>
<pre>
(!No | (Ni=No)) &amp; (!Ki | (Ki=Ko)) &amp; (!Hi | (Hi=Ho)) &amp; (E No | E Hi)
</pre>
<p id="rfc.section.9.p.4">As one can see, there are two types of attributes one can match.  The first term depends on the existence of the attribute in the Content Object while the next two terms depend on the existence of the attribute in the Interest.  The last term is the "Nameless Object" restriction which states that if a Content Object does not have a Name, then it must match the Interest on at least the Hash restriction.</p>
<p id="rfc.section.9.p.5">If a Content Object does not carry the Content ObjectHash as an expressed field, it must be calculated in network to match against. It is sufficient within an autonomous system to calculate a Content ObjectHash at a border router and carry it via trusted means within the autonomous system. If a Content Object ValidationAlgorithm does not have a KeyId then the Content Object cannot match an Interest with a KeyIdRestr.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#InterestReturn" id="InterestReturn">Interest Return</a>
</h1>
<p id="rfc.section.10.p.1">This section describes the process whereby a network element may return an Interest message to a previous hop if there is an error processing the Interest. The returned Interest may be further processed at the previous hop or returned towards the Interest origin.  When a node returns an Interest it indicates that the previous hop should not expect a response from that node for the Interest -- i.e., there is no PIT entry left at the returning node.</p>
<p id="rfc.section.10.p.2">The returned message maintains compatibility with the existing TLV packet format (a fixed header, optional hop-by-hop headers, and the CCNx message body). The returned Interest packet is modified in only two ways: </p>

<ul>
<li>The PacketType is set to InterestReturn to indicate a Feedback message.  </li>
<li>The ReturnCode is set to the appropriate value to signal the reason for the return </li>
</ul>

<p> </p>
<p id="rfc.section.10.p.3">The specific encodings of the Interest Return are specified in <a href="#CCNMessages" class="xref">[CCNMessages]</a>.</p>
<p id="rfc.section.10.p.4">A Forwarder is not required to send any Interest Return messages.</p>
<p id="rfc.section.10.p.5">A Forwarder is not required to process any received Interest Return message.  If a Forwarder does not process Interest Return messages, it SHOULD silently drop them.</p>
<p id="rfc.section.10.p.6">The Interest Return message does not apply to a Content Object or any other message type.</p>
<p id="rfc.section.10.p.7">An Interest Return message is a 1-hop message between peers.  It is not propagated multiple hops via the FIB.  An intermediate node that receives an InterestReturn may take corrective actions or may propagate its own InterestReturn to previous hops as indicated in the reverse path of a PIT entry.</p>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#MessageFormat" id="MessageFormat">Message Format</a>
</h1>
<p id="rfc.section.10.1.p.1">The Interest Return message looks exactly like the original Interest message with the exception of the two modifications mentioned above.  The PacketType is set to indicate the message is an InterestReturn and the reserved byte in the Interest header is used as a Return Code.  The numeric values for the PacketType and ReturnCodes are in <a href="#CCNMessages" class="xref">[CCNMessages]</a>.</p>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> <a href="#TypeDefinitions" id="TypeDefinitions">ReturnCode Types</a>
</h1>
<p id="rfc.section.10.2.p.1">This section defines the InterestReturn ReturnCode introduced in this RFC.  The numeric values used in the packet are defined in <a href="#CCNMessages" class="xref">[CCNMessages]</a>.</p>
<div id="rfc.table.3"></div>
<div id="ReasonCode"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Interest Return Reason Codes</caption>
<thead><tr>
<th class="left">Name</th>
<th class="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td class="left">
<a href="#NoRoute" class="xref">No Route</a> </td>
<td class="left">The returning Forwarder has no route to the Interest name.</td>
</tr>
<tr>
<td class="left">
<a href="#HopLimit" class="xref">HopLimit Exceeded</a> </td>
<td class="left">The HopLimit has decremented to 0 and need to forward the packet.</td>
</tr>
<tr>
<td class="left">
<a href="#MTU" class="xref">Interest MTU too large</a> </td>
<td class="left">The Interest's MTU does not conform to the required minimum and would require fragmentation.</td>
</tr>
<tr>
<td class="left">
<a href="#NoResources" class="xref">No Resources</a> </td>
<td class="left">The node does not have the resources to process the Interest.</td>
</tr>
<tr>
<td class="left">
<a href="#PathError" class="xref">Path error</a> </td>
<td class="left">There was a transmission error when forwarding the Interest along a route (a transient error).</td>
</tr>
<tr>
<td class="left">
<a href="#Prohibited" class="xref">Prohibited</a> </td>
<td class="left">An administrative setting prohibits processing this Interest.</td>
</tr>
<tr>
<td class="left">
<a href="#Congestion" class="xref">Congestion</a> </td>
<td class="left">The Interest was dropped due to congestion (a transient error).</td>
</tr>
<tr>
<td class="left">
<a href="#UnsupportedHashAlgorithm" class="xref">Unsupported Content Object Hash Algorithm</a> </td>
<td class="left">The Interest was dropped because it requested a Content Object Hash Restriction using a hash algorithm that cannot be computed.</td>
</tr>
<tr>
<td class="left">
<a href="#MalformedInterest" class="xref">Malformed Interest</a> </td>
<td class="left">The Interest was dropped because it did not correctly parse.</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.10.3">
<a href="#rfc.section.10.3">10.3.</a> <a href="#InterestReturnProtocol" id="InterestReturnProtocol">Interest Return Protocol</a>
</h1>
<p id="rfc.section.10.3.p.1">This section describes the Forwarder behavior for the various Reason codes for Interest Return.  A Forwarder is not required to generate any of the codes, but if it does, it MUST conform to this specification.</p>
<p id="rfc.section.10.3.p.2">If a Forwarder receives an Interest Return, it SHOULD take these standard corrective actions.  A forwarder is allowed to ignore Interest Return messages, in which case its PIT entry would go through normal timeout processes.  </p>

<ul>
<li>Verify that the Interest Return came from a next-hop to which it actually sent the Interest.</li>
<li>If a PIT entry for the corresponding Interest does not exist, the Forwarder should ignore the Interest Return.</li>
<li>If a PIT entry for the corresponding Interest does exist, the Forwarder MAY do one of the following: <ul>
<li>Try a different forwarding path, if one exists, and discard the Interest Return, or</li>
<li>Clear the PIT state and send an Interest Return along the reverse path.</li>
</ul>
<p> </p>
</li>
</ul>

<p> </p>
<p id="rfc.section.10.3.p.3">If a forwarder tries alternate routes, it MUST ensure that it does not use same same path multiple times.  For example, it could keep track of which next hops it has tried and not re-use them.</p>
<p id="rfc.section.10.3.p.4">If a forwarder tries an alternate route, it may receive a second InterestReturn, possibly of a different type than the first InterestReturn.  For example, node A sends an Interest to node B, which sends a No Route return.  Node A then tries node C, which sends a Prohibited.  Node A should choose what it thinks is the appropriate code to send back to its previous hop</p>
<p id="rfc.section.10.3.p.5">If a forwarder tries an alternate route, it should decrement the Interest Lifetime to account for the time spent thus far processing the Interest.</p>
<h1 id="rfc.section.10.3.1">
<a href="#rfc.section.10.3.1">10.3.1.</a> <a href="#NoRoute" id="NoRoute">No Route</a>
</h1>
<p id="rfc.section.10.3.1.p.1">If a Forwarder receives an Interest for which it has no route, or for which the only route is back towards the system that sent the Interest, the Forwarder SHOULD generate a "No Route" Interest Return message.</p>
<p id="rfc.section.10.3.1.p.2">How a forwarder manages the FIB table when it receives a No Route message is implementation dependent.  In general, receiving a No Route Interest Return should not cause a forwarder to remove a route.  The dynamic routing protocol that installed the route should correct the route or the administrator who created a static route should correct the configuration.  A forwarder could suppress using that next hop for some period of time.</p>
<h1 id="rfc.section.10.3.2">
<a href="#rfc.section.10.3.2">10.3.2.</a> <a href="#HopLimit" id="HopLimit">HopLimit Exceeded</a>
</h1>
<p id="rfc.section.10.3.2.p.1">A Forwarder MAY choose to send HopLimit Exceeded messages when it receives an Interest that must be forwarded off system and the HopLimit is 0.</p>
<h1 id="rfc.section.10.3.3">
<a href="#rfc.section.10.3.3">10.3.3.</a> <a href="#MTU" id="MTU">Interest MTU Too Large</a>
</h1>
<p id="rfc.section.10.3.3.p.1">If a Forwarder receives an Interest whose MTU exceeds the prescribed minimum, it MAY send an "Interest MTU Too Large" message, or it may silently discard the Interest.</p>
<p id="rfc.section.10.3.3.p.2">If a Forwarder receives an "Interest MTU Too Large" is SHOULD NOT try alternate paths.  It SHOULD propagate the Interest Return to its previous hops.</p>
<h1 id="rfc.section.10.3.4">
<a href="#rfc.section.10.3.4">10.3.4.</a> <a href="#NoResources" id="NoResources">No Resources</a>
</h1>
<p id="rfc.section.10.3.4.p.1">If a Forwarder receives an Interest and it cannot process the Interest due to lack of resources, it MAY send an InterestReturn.  A lack of resources could be the PIT table is too large, or some other capacity limit.</p>
<h1 id="rfc.section.10.3.5">
<a href="#rfc.section.10.3.5">10.3.5.</a> <a href="#PathError" id="PathError">Path Error</a>
</h1>
<p id="rfc.section.10.3.5.p.1">If a forwarder detects an error forwarding an Interest, such as over a reliable link, it MAY send a Path Error Interest Return indicating that it was not able to send or repair a forwarding error.</p>
<h1 id="rfc.section.10.3.6">
<a href="#rfc.section.10.3.6">10.3.6.</a> <a href="#Prohibited" id="Prohibited">Prohibited</a>
</h1>
<p id="rfc.section.10.3.6.p.1">A forwarder may have administrative policies, such as access control lists, that prohibit receiving or forwarding an Interest.  If a forwarder discards an Interest due to a policy, it MAY send a Prohibited InterestReturn to the previous hop. For example, if there is an ACL that says /parc/private can only come from interface e0, but the Forwarder receives one from e1, the Forwarder must have a way to return the Interest with an explanation.</p>
<h1 id="rfc.section.10.3.7">
<a href="#rfc.section.10.3.7">10.3.7.</a> <a href="#Congestion" id="Congestion">Congestion</a>
</h1>
<p id="rfc.section.10.3.7.p.1">If a forwarder discards an Interest due to congestion, it MAY send a Congestion InterestReturn to the previous hop.</p>
<h1 id="rfc.section.10.3.8">
<a href="#rfc.section.10.3.8">10.3.8.</a> <a href="#UnsupportedHashAlgorithm" id="UnsupportedHashAlgorithm">Unsupported Content Object Hash Algorithm</a>
</h1>
<p id="rfc.section.10.3.8.p.1">If a Content Object Hash Restriction specifies a hash algorithm the forwarder cannot verify, the Interest should not be accepted and the forwarder MAY send an InterestReturn to the previous hop.</p>
<h1 id="rfc.section.10.3.9">
<a href="#rfc.section.10.3.9">10.3.9.</a> <a href="#MalformedInterest" id="MalformedInterest">Malformed Interest</a>
</h1>
<p id="rfc.section.10.3.9.p.1">If a forwarder detects a structural or syntactical error in an Interest, it SHOULD drop the interest and MAY send an InterestReturn to the previous hop.  This does not imply that any router must validate the entire structure of an Interest.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.11.p.1">This memo includes no request to IANA. </p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.12.p.1">The CCNx protocol is a layer 3 network protocol, which may also operate as an overlay using other transports, such as UDP or other tunnels.  It includes intrinsic support for message authentication via a signature (e.g. RSA or elliptic curve) or message authentication code (e.g. HMAC).  In lieu of an authenticator, it may instead use a message integrity check (e.g. SHA or CRC).  CCNx does not specify an encryption envelope, that function is left to a high-layer protocol (e.g. <a href="#esic" class="xref">[esic]</a>).</p>
<p id="rfc.section.12.p.2">The CCNx message format includes the ability to attach MICs (e.g. SHA-256 or CRC), MACs (e.g. HMAC), and Signatures (e.g. RSA or ECDSA) to all packet types.  This does not mean that it is a good idea to use an arbitrary ValidationAlgorithm, nor to include computationally expensive algorithms in Interest packets, as that could lead to computational DoS attacks.  Applications should use an explicit protocol to guide their use of packet signatures.  As a general guideline, an application might use a MIC on an Interest to detect unintentionally corrupted packets.  If one wishes to secure an Interest, one should consider using an encrypted wrapper and a protocol that prevents replay attacks, especially if the Interest is being used as an actuator.  Simply using an authentication code or signature does not make an Interests secure.  There are several examples in the literature on how to secure ICN-style messaging <a href="#mobile" class="xref">[mobile]</a> <a href="#ace" class="xref">[ace]</a>.  </p>
<p id="rfc.section.12.p.3">As a layer 3 protocol, this document does not describe how one arrives at keys or how one trusts keys.  The CCNx content object may include a public key embedded in the object or may use the PublicKeyLocator field to point to a public key (or public key certificate) that authenticates the message.  One key exchange specification is <a href="#ccnxke" class="xref">CCNxKE</a> <a href="#mobile" class="xref">[mobile]</a>, which is similar to the TLS 1.3 key exchange except it is over the CCNx layer 3 messages.  Trust is beyond the scope of a layer-3 protocol protocol and left to applications or application frameworks.  </p>
<p id="rfc.section.12.p.4">The combination of an ephemeral key exchange (e.g. <a href="#ccnxke" class="xref">CCNxKE</a>) and an encapsulating encryption (e.g. <a href="#esic" class="xref">[esic]</a>) provides the equivalent of a TLS tunnel.  Intermediate nodes may forward the Interests and Content Objects, but have no visibility inside.  It also completely hides the internal names in those used by the encryption layer.  This type of tunneling encryption is useful for content that has little or no cache-ability as it can only be used by someone with the ephemeral key.  Short term caching may help with lossy links or mobility, but long term caching is usually not of interest.  </p>
<p id="rfc.section.12.p.5">Broadcast encryption or proxy re-encryption may be useful for content with multiple uses over time or many consumers.  There is currently no recommendation for this form of encryption.  </p>
<p id="rfc.section.12.p.6">The specific encoding of messages will have security implications.  <a href="#CCNMessages" class="xref">[CCNMessages]</a> uses a type-length-value (TLV) encoding.  We chose to compromise between extensibility and unambiguous encodings of types and lengths.  Some TLVs use variable length T and variable length L fields to accomodate a wide gamut of values while trying to be byte-efficient.  Our TLV encoding uses a fixed length 2-byte T and 2-byte L.  Using a fixed-length T and L field solves two problems.  The first is aliases.  If one is able to encode the same value, such as 0x2 and 0x02, in different byte lengths then one must decide if they mean the same thing, if they are different, or if one is illegal.  If they are different, then one must always compare on the buffers not the integer equivalents.  If one is illegal, then one must validate the TLV encoding -- every field of every packet at every hop.  If they are the same, then one has the second problem: how to specify packet filters.  For example, if a name has 6 name components, then there are 7 T's and 7 L's, each of which might have up to 4 representations of the same value.  That would be 14 fields with 4 encodings each, or 1001 combinations.  It also means that one cannot compare, for example, a name via a memory function as one needs to consider that any embedded T or L might have a different format.</p>
<p id="rfc.section.12.p.7">The Interest Return message has no authenticator from the previous hop.  Therefore, the payload of the Interest Return should only be used locally to match an Interest.  A node should never forward that Interest payload as an Interest.  It should also verify that it sent the Interest in the Interest Return to that node and not allow anyone to negate Interest messages.</p>
<p id="rfc.section.12.p.8">Caching nodes must take caution when processing content objects.  It is essential that the Content Store obey the rules outlined in <a href="#contentstore" class="xref">Section 2.4.3</a> to avoid certain types of attacks.  Unlike NDN, CCNx 1.0 has no mechanism to work around an undesired result from the network (there are no "excludes"), so if a cache becomes poisoned with bad content it might cause problems retrieving content.   There are three types of access to content from a content store: unrestricted, signature restricted, and hash restricted.  If an Interest has no restrictions, then the requester is not particular about what they get back, so any matching cached object is OK.  In the hash restricted case, the requester is very specific about what they want and the content store (and every forward hop) can easily verify that the content matches the request.  In the signature verified case (often used for initial manifest discovery), the requester only knows the KeyId that signed the content.  It is this case that requires the closest attention in the content store to avoid amplifying bad data.  The content store must only respond with a content object if it can verify the signature -- this means either the content object carries the public key inside it or the Interest carries the public key in addition to the KeyId.  If that is not the case, then the content store should treat the Interest as a cache miss and let an endpoint respond.  </p>
<p id="rfc.section.12.p.9">A user-level cache could perform full signature verification by fetching a public key according to the PublicKeyLocator.  That is not, however, a burden we wish to impose on the forwarder.  A user-level cache could also rely on out-of-band attestation, such as the cache operator only inserting content that it knows has the correct signature.</p>
<p id="rfc.section.12.p.10">The CCNx grammar allows for hash algorithm agility via the HashType.  It specifies a short list of acceptable hash algorithms that should be implemented at each forwarder.  Some hash values only apply to end systems, so updating the hash algorithm does not affect forwarders -- they would simply match the buffer that includes the type-length-hash buffer.  Some fields, such as the ConObjHash, must be verified at each hop, so a forwarder (or related system) must know the hash algorithm and it could cause backward compatibility problems if the hash type is updated.  <a href="#CCNMessages" class="xref">[CCNMessages]</a> is the authoritative source for per-field allowed hash types in that encoding.</p>
<p id="rfc.section.12.p.11">A CCNx name uses binary matching whereas a URI uses a case insensitive hostname.  Some systems may also use case insensitive matching of the URI path to a resource.  An implication of this is that human-entered CCNx names will likely have case or non-ASCII symbol mismatches unless one uses a consistent URI normalization to the CCNx name.  It also means that an entity that registers a CCNx routable prefix, say ccnx:/example.com, would need separate registrations for simple variations like ccnx:/Example.com.  Unless this is addressed in URI normalization and routing protocol conventions, there could be phishing attacks.</p>
<p id="rfc.section.12.p.12">For a more general introduction to ICN-related security concerns and approaches, see <a href="#RFC7927" class="xref">[RFC7927]</a> and <a href="#RFC7945" class="xref">[RFC7945]</a></p>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table><tbody><tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr></tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="ace">[ace]</b></td>
<td class="top">
<a title="University of California, Los Angeles">Shang, W.</a>, <a title="University of California, Los Angeles">Yu, Y.</a>, <a title="University of Arizona">Liang, T.</a>, <a title="University of Arizona">Zhang, B.</a> and <a title="University of California, Los Angeles">L. Zhang</a>, "<a href="http://new.named-data.net/wp-content/uploads/2015/12/ndn-0036-1-ndn-ace.pdf">NDN-ACE: Access control for constrained environments over named data networking</a>", NDN Technical Report NDN-0036, 2015.</td>
</tr>
<tr>
<td class="reference"><b id="befrags">[befrags]</b></td>
<td class="top">
<a title="PARC, Inc.">Mosko, M.</a> and <a title="University of Basel">C. Tschudin</a>, "<a href="https://www.ietf.org/archive/id/draft-mosko-icnrg-beginendfragment-02.txt">ICN "Begin-End" Hop by Hop Fragmentation</a>", 2017.</td>
</tr>
<tr>
<td class="reference"><b id="ccnlite">[ccnlite]</b></td>
<td class="top">
<a>Tschudin, C., et al., University of Basel</a>, "<a href="http://www.ccn-lite.net/">CCN-Lite V2</a>", 2011-2018.</td>
</tr>
<tr>
<td class="reference"><b id="CCNMessages">[CCNMessages]</b></td>
<td class="top">
<a title="PARC, Inc.">Mosko, M.</a>, <a title="LinkedIn">Solis, I.</a> and <a title="University of California, Irvine">C. Wood</a>, "<a href="https://www.ietf.org/id/draft-irtf-icnrg-ccnxmessages-07.txt">CCNx Messages in TLV Format (Internet draft)</a>", 2018.</td>
</tr>
<tr>
<td class="reference"><b id="ccnxke">[ccnxke]</b></td>
<td class="top">
<a title="PARC, Inc.">Mosko, M.</a>, <a title="PARC, Inc.">Uzun, E.</a> and <a title="University of California, Irvine">C. Wood</a>, "<a href="https://www.ietf.org/archive/id/draft-wood-icnrg-ccnxkeyexchange-02.txt">CCNx Key Exchange Protocol Version 1.0</a>", 2017.</td>
</tr>
<tr>
<td class="reference"><b id="CCNxURI">[CCNxURI]</b></td>
<td class="top">
<a title="PARC, Inc.">Mosko, M.</a> and <a title="University of California, Irvine">C. Wood</a>, "<a href="http://tools.ietf.org/html/draft-mosko-icnrg-ccnxuri-02">The CCNx URI Scheme (Internet draft)</a>", 2017.</td>
</tr>
<tr>
<td class="reference"><b id="chunking">[chunking]</b></td>
<td class="top">
<a title="PARC, Inc.">Mosko, M.</a>, "<a href="https://www.ietf.org/archive/id/draft-mosko-icnrg-ccnxchunking-02.txt">CCNx Content Object Chunking</a>", 2016.</td>
</tr>
<tr>
<td class="reference"><b id="cicn">[cicn]</b></td>
<td class="top">
<a>Muscariello, L., et al., Cisco Systems</a>, "<a href="https://wiki.fd.io/view/Cicn">Community ICN (CICN)</a>", 2017-2018.</td>
</tr>
<tr>
<td class="reference"><b id="dart">[dart]</b></td>
<td class="top">
<a title="PARC, Inc.">Garcia-Luna-Aceves, J.</a> and <a title="University of California, Santa Cruz">M. Mirzazad-Barijough</a>, "<a href="https://arxiv.org/pdf/1603.06044.pdf">A Light-Weight Forwarding Plane for Content-Centric Networks</a>", 2016.</td>
</tr>
<tr>
<td class="reference"><b id="EpriseNumbers">[EpriseNumbers]</b></td>
<td class="top">
<a>IANA</a>, "<a href="http://www.iana.org/assignments/enterprise-numbers/enterprise-numbers">IANA Private Enterprise Numbers</a>", 2015.</td>
</tr>
<tr>
<td class="reference"><b id="esic">[esic]</b></td>
<td class="top">
<a title="PARC, Inc.">Mosko, M.</a> and <a title="University of California, Irvine">C. Wood</a>, "<a href="https://www.ietf.org/id/draft-wood-icnrg-esic-01.txt">Encrypted Sessions In CCNx (ESIC)</a>", 2017.</td>
</tr>
<tr>
<td class="reference"><b id="flic">[flic]</b></td>
<td class="top">
<a title="University of Basel">Tschudin, C.</a> and <a title="University of California, Irvine">C. Wood</a>, "<a href="https://www.ietf.org/archive/id/draft-tschudin-icnrg-flic-03.txt">File-Like ICN Collection (FLIC)</a>", 2017.</td>
</tr>
<tr>
<td class="reference"><b id="mobile">[mobile]</b></td>
<td class="top">
<a title="PARC, Inc.">Mosko, M.</a>, <a title="PARC, Inc.">Uzun, E.</a> and <a title="University of California, Irvine">C. Wood</a>, "<a href="http://dl.ifip.org/db/conf/networking/networking2017/1570334964.pdf">Mobile Sessions in Content-Centric Networks</a>", IFIP Networking, 2017.</td>
</tr>
<tr>
<td class="reference"><b id="ndn">[ndn]</b></td>
<td class="top">
<a>UCLA</a>, "<a href="http://www.named-data.net">Named Data Networking</a>", 2007.</td>
</tr>
<tr>
<td class="reference"><b id="nnc">[nnc]</b></td>
<td class="top">
<a title="Palo Alto Research Center">Jacobson, V.</a>, <a title="Palo Alto Research Center">Smetters, D.</a>, <a title="Palo Alto Research Center">Thornton, J.</a>, <a title="Palo Alto Research Center">Plass, M.</a>, <a title="Palo Alto Research Center">Briggs, N.</a> and <a title="Palo Alto Research Center">R. Braynard</a>, "<a href="http://dx.doi.org/10.1145/1658939.1658941">Networking Named Content</a>", 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7927">[RFC7927]</b></td>
<td class="top">
<a title="NEC">Kutscher, D.</a>, <a title="Osaka University">Eum, S.</a>, <a title="Travelping">Pentikousis, K.</a>, <a title="UCL">Psaras, I.</a>, <a title="Universidade de Aveiro">Corujo, D.</a>, <a title="INRIA">Saucez, D.</a>, <a title="HAW Hamburg">Schmidt, T.</a> and <a title="FU Berlin">M. Waehlisch</a>, "<a href="https://trac.tools.ietf.org/html/rfc7927">Information-Centric Networking (ICN) Research Challenges</a>", 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7945">[RFC7945]</b></td>
<td class="top">
<a title="Travelping">Pentikousis, K.</a>, <a title="Ericsson">Ohlman, B.</a>, <a title="Trinity College Dublin">Davies, E.</a>, <a title="Intracom Telecom">Spirou, S.</a> and <a title="Politecnico di Bari">G. Boggia</a>, "<a href="https://trac.tools.ietf.org/html/rfc7945">Information-Centric Networking: Evaluation and Security Considerations</a>", 2016.</td>
</tr>
<tr>
<td class="reference"><b id="selectors">[selectors]</b></td>
<td class="top">
<a title="PARC, Inc.">Mosko, M.</a>, "<a href="https://raw.githubusercontent.com/mmosko/ccnx-protocol-rfc/master/docs/build/draft-mosko-icnrg-selectors-01.txt">CCNx Selector Based Discovery</a>", 2017.</td>
</tr>
<tr>
<td class="reference"><b id="terminology">[terminology]</b></td>
<td class="top">
<a title="TNO">Wissingh, B.</a>, <a title="University of California Irvine">Wood, C.</a>, <a title="UCLA">Afanasyev, A.</a>, <a title="UCLA">Zhang, L.</a>, <a title="Network Systems Research &amp; Design">Oran, D.</a> and <a title="University of Basel">C. Tschudin</a>, "<a href="https://www.ietf.org/id/draft-irtf-icnrg-terminology-00.txt">Information-Centric Networking (ICN): CCN and NDN Terminology</a>", 2017.</td>
</tr>
<tr>
<td class="reference"><b id="trust">[trust]</b></td>
<td class="top">
<a title="University of Basel">Tschudin, C.</a>, <a title="PARC, Inc.">Uzun, E.</a> and <a title="University of California, Irvine">C. Wood</a>, "<a href="https://doi.org/10.1109/ICCCN.2016.7568589">Trust in Information-Centric Networking: From Theory to Practice</a>", 2016.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Marc Mosko</span> 
	  <span class="n hidden">
		<span class="family-name">Mosko</span>
	  </span>
	</span>
	<span class="org vcardline">PARC, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Palo Alto</span>,  
		<span class="region">California</span> 
		<span class="code">94304</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +01 650-812-4405</span>

<span class="vcardline">EMail: <a href="mailto:marc.mosko@parc.com">marc.mosko@parc.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ignacio Solis</span> 
	  <span class="n hidden">
		<span class="family-name">Solis</span>
	  </span>
	</span>
	<span class="org vcardline">LinkedIn</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Mountain View</span>,  
		<span class="region">California</span> 
		<span class="code">94043</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nsolis@linkedin.com">nsolis@linkedin.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">University of California Irvine</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Irvine</span>,  
		<span class="region">California</span> 
		<span class="code">92697</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +01 315-806-5939</span>

<span class="vcardline">EMail: <a href="mailto:woodc1@uci.edu">woodc1@uci.edu</a></span>

  </address>
</div>

</body>
</html>
